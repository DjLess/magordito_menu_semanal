<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selecci√≥n de Men√∫s e Ingredientes</title>
    <style>
        /* ======================================================================= */
        /* VARIABLES DE CARTA DE INGREDIENTE Y PLATO (Integradas de pantalla3.html) */
        /* ======================================================================= */
        :root {
            --bg-color: #0d1117;
            --text-color: #c9d1d9;
            --card-bg-color: #2b313a; 
            --card-border-color: #484f58;
            --selection-color: #58a6ff;
            --success-color: #238636;
            --failure-color: #a00000;
            --lift-amount: 0px; 
            
            /* VARIABLES PARA TARJETA DE INGREDIENTE (Ajustadas para la Galer√≠a) */
            --ing-card-width: 90px; 
            --ing-card-aspect-ratio: calc(70 / 49); 
            --ing-card-calculated-height: calc(var(--ing-card-width) * var(--ing-card-aspect-ratio)); 
            
            /* VARIABLES PARA TARJETA DE PLATO (Ajustadas para la Galer√≠a) */
            --dish-card-width: 120px; 
            --dish-card-aspect-ratio: calc(70 / 49);
            --dish-card-calculated-height: calc(var(--dish-card-width) * var(--dish-card-aspect-ratio));
        }
        
        /* Estilos base */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 10px;
            text-align: center;
            font-size: 0.85em; 
        }
        
        h2 {
            font-size: 1.4em;
            margin-bottom: 20px;
            color: var(--selection-color);
        }

        #main-container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            text-align: left;
        }

        .list-section {
            flex: 1;
            min-width: 45%;
        }

        .list-section h3 {
            color: var(--success-color);
            border-bottom: 1px solid #30363d;
            padding-bottom: 5px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        /* Contenedor de Ingredientes Personalizados (Detalles) */
        #custom-ingredients-section {
            background-color: #161b22;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #30363d;
            text-align: left; /* Asegura que el contenido interno sea legible */
        }
        
        #custom-ingredients-section details {
             background-color: #1f242b;
             border-radius: 6px;
             border: 1px solid #484f58;
             padding: 10px;
        }
        
        #custom-ingredients-section summary {
            font-weight: bold;
            font-size: 1.1em;
            color: #ffa500; /* Color naranja para destacar Custom */
            cursor: pointer;
            padding: 5px;
        }
        
        #custom-ingredients-list {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #30363d;
        }


        /* ------------------------------------------------------------------- */
        /* LAYOUT DE COLUMNAS CON CSS GRID (Nuevo) */
        /* ------------------------------------------------------------------- */

        #dishes-list, #ingredients-list {
            display: grid;
            /* Columnas autom√°ticas con un m√≠nimo de 110px para platos, 80px para ingredientes */
            grid-template-columns: repeat(auto-fill, minmax(var(--dish-card-width), 1fr)); 
            gap: 15px; 
            padding: 10px;
            max-height: 70vh; 
            overflow-y: auto; 
            background-color: #161b22; /* Fondo de lista */
            border: 1px solid #30363d;
            border-radius: 8px;
        }
        
        #ingredients-list {
            grid-template-columns: repeat(auto-fill, minmax(var(--ing-card-width), 1fr)); 
        }

        /* Contenedor de la Tarjeta dentro del Grid */
        .list-item { 
            display: block; 
            padding: 0;
            margin-bottom: 0;
            background-color: transparent;
            border: none;
            cursor: pointer;
            position: relative;
        }

        .list-item:hover {
            background-color: transparent;
        }

        /* Clase para items seleccionados */
        .list-item.selected .ingredient-card,
        .list-item.selected .result-dish-card {
            border-color: var(--selection-color) !important;
            box-shadow: 0 0 10px var(--selection-color);
            transform: scale(1.02);
        }

        /* ------------------------------------------------------------------- */
        /* ESTILOS DE CARTA DE INGREDIENTE (Adaptados de pantalla3.html) */
        /* ------------------------------------------------------------------- */
        .ingredient-card {
            width: 100%; 
            height: 0;
            padding-bottom: calc(100% * var(--ing-card-aspect-ratio)); 
            
            background-color: var(--card-bg-color); 
            border: 2px solid var(--card-border-color); 
            border-radius: 10px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            user-select: none;
            
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.2s;
        }
        
        .ingredient-card:hover {
            transform: scale(1.05); 
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.6);
        }

        .ingredient-card > div.card-content-wrapper {
            position: absolute;
            top: 5px; 
            left: 5px; 
            width: calc(100% - 10px); 
            height: calc(100% - 10px); 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            
            background-color: #1f242b; 
            border-radius: 6px; 
            box-sizing: border-box; 
            padding-top: 20px;
            padding-bottom: 5px;
        }
        
        .card-corner {
            position: absolute;
            font-size: 0.9em; 
            font-weight: 700;
            line-height: 1;
            z-index: 5;
            color: var(--text-color);
            pointer-events: none; 
            top: 7px;
            left: 7px;
        }

        .card-emoji {
            font-size: 2.5em; 
            line-height: 1;
            flex-grow: 1; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-name {
            font-size: 0.8em; 
            font-weight: 600;
            text-align: center;
            padding: 0 3px;
            height: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            overflow: hidden; 
            text-overflow: ellipsis;
            line-height: 1.1;
        }
        
        /* Colores de Marco por Tipo */
        .ingredient-card[data-type="Principal"] { border-color: #ff4081; } /* Rosado */
        .ingredient-card[data-type="Carbohidrato"] { border-color: #ffeb3b; } /* Amarillo */
        .ingredient-card[data-type="Verdura"] { border-color: #4caf50; } /* Verde */
        .ingredient-card[data-type="Custom"] { border-color: #ffa500; } /* Naranja */
        
        /* Controles de la Tarjeta de Ingrediente */
        .ingredient-controls-overlay {
            position: absolute;
            bottom: 0px; 
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 5px 5px 5px;
            background: rgba(13, 17, 23, 0.7); 
            border-radius: 0 0 10px 10px;
            box-sizing: border-box;
            z-index: 10;
            height: 30px; 
        }
        
        .ingredient-controls-overlay .availability-select {
            width: 50px; 
            font-size: 0.7em;
            padding: 2px;
        }
        
        .ingredient-controls-overlay input[type="checkbox"] {
            width: 18px; 
            height: 18px;
            accent-color: var(--success-color);
        }

        /* ------------------------------------------------------------------- */
        /* ESTILO DE CARTA DE PLATO (Adaptados de pantalla3.html) */
        /* ------------------------------------------------------------------- */
        .result-dish-card {
            width: 100%; 
            height: 0;
            padding-bottom: var(--dish-card-calculated-height); 
            
            background-color: var(--card-bg-color); 
            border: 2px solid var(--card-border-color);
            border-radius: 8px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5); 
            
            margin: 0; 
            cursor: pointer;
            position: relative; 
            user-select: none;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }
        
        .result-dish-card:hover {
            transform: scale(1.05); 
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.6), 0 0 10px rgba(88, 166, 255, 0.3);
        }
        
        .result-dish-card .card-inner-content {
            position: absolute;
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            display: flex;
            flex-direction: column;
            padding: 3px; 
            box-sizing: border-box;
            background-color: #1f242b; 
            border-radius: 6px;
        }
        
        .result-dish-card .card-image-zone {
            flex: 0 0 45%; 
            width: 100%;
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border-radius: 4px;
            margin-bottom: 2px;
            background-color: #38404a; 
            padding: 5px 0;
        }

        .result-dish-card .card-main-emoji {
            font-size: 2em; 
            line-height: 1; 
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.4), 0 0 7px rgba(0, 0, 0, 0.8);
            flex-grow: 1; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-dish-card .card-secondary-emojis {
            display: none; /* Simplificado para la galer√≠a */
        }
        
        .result-dish-card .card-ingredients-zone {
            flex: 1; 
            width: 100%;
            background-color: #38404a;
            border-radius: 4px;
            padding: 5px;
            overflow-y: auto; /* Permitir scroll si la lista es larga */
            color: #f0f6fc;
            text-align: center;
            font-size: 0.75em; 
            line-height: 1.1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; 
            position: relative;
        }

        .result-dish-card .card-dish-name {
            position: relative;
            font-size: 0.85em; 
            font-weight: 600;
            text-align: center;
            margin-bottom: 3px;
            line-height: 1.1;
        }

        .result-dish-card .card-ingredients-list {
            position: relative;
            text-align: left;
            font-size: 0.6em; 
            line-height: 1.2;
            list-style: none;
            padding: 0 3px;
            margin: 0;
            flex-grow: 1;
        }
        
        .result-dish-card .card-ingredients-list li {
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .dish-controls-overlay {
            position: absolute;
            bottom: 5px; 
            right: 5px;
            z-index: 10;
        }
        
        .dish-controls-overlay input[type="checkbox"] {
            width: 18px; 
            height: 18px;
            accent-color: var(--success-color);
        }
        
        /* ------------------------------------------------------------------- */
        /* Estilos de Ingredientes Personalizados y Botones (Mantenidos) */
        /* ------------------------------------------------------------------- */

        .custom-ingredient-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            border-bottom: 1px dashed #30363d;
            padding-bottom: 10px;
        }
        
        .tool-button-group {
            display: flex; 
            justify-content: center; 
            gap: 15px;
            margin-bottom: 20px; 
        }
        
        /* ------------------------------------------------------------------- */
        /* Responsive */
        /* ------------------------------------------------------------------- */
        @media (max-width: 768px) {
            #main-container {
                flex-direction: column;
            }
            .list-section {
                min-width: 100%;
            }
            #dishes-list, #ingredients-list {
                /* Permitir tarjetas m√°s peque√±as en m√≥vil */
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); 
            }
            .custom-ingredient-item {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>

    <div id="global-controls" style="text-align: center; margin-bottom: 20px;">
        <button onclick="selectAllDishes()" style="background-color: #238636; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; margin-right: 10px;">‚úÖ Marcar Todos los Platos</button>
        <button onclick="deselectAllDishes()" style="background-color: #a00000; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer;">‚ùå Desmarcar Todos los Platos</button>
    </div>

    <h2>Lista de Platos e Ingredientes (Con Selecci√≥n de Tarjetas)</h2>
    
    <div id="loading-message" style="color: #58a6ff; margin-top: 15px; text-align: center;">Cargando men√∫ desde GitHub...</div>

    <div id="custom-ingredients-section">
        <details>
            <summary>‚ú® Configuraci√≥n de Ingredientes Personalizados (5 Slots)</summary>
            <p style="font-size:0.8em; color: #8b949e; margin-top: 10px; margin-bottom: 10px;">Define un ingrediente, su categor√≠a, el plato asociado y la **disponibilidad (veces)**. Haz clic en "Aplicar" para guardar y actualizar las listas.</p>
            <div id="custom-ingredients-list">
                </div>
            <div id="custom-status" style="margin-top: 10px; color: #f75555; text-align: center;"></div>
        </details>
    </div>
    
    <div id="main-container">
        <div class="list-section">
            <h3>Platos Principales</h3>
            <div id="dishes-list">
                </div>
        </div>
        <div class="list-section">
            <h3>Ingredientes (Est√°ndar y Personalizados)</h3>
            <div id="ingredients-list">
                </div>
        </div>
    </div>
    
    <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #30363d;">
        <h3 style="color: #58a6ff; margin-bottom: 15px; font-size: 1.2em;">Otras Herramientas</h3>
        <div class="tool-button-group">
            <button onclick="window.location.href='pantalla7.html'" style="background-color: #238636; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">JUEGO (Pantalla 7)</button>
            <button onclick="window.location.href='pantalla2.html'" style="background-color: #58a6ff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">GENERADOR DE MEN√ö</button>
            <button onclick="saveAndClose()" style="background-color: #a00000; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Guardar y Cerrar</button>
        </div>
    </div>
    <script>
    // ===============================================
    // *** FUNCI√ìN loadContent A√ëADIDA PARA SOPORTE ***
    // ===============================================
    function loadContent(filePath) {
        console.log("Navegando a:", filePath);
        if (typeof window.parent.loadContent === 'function') {
            window.parent.loadContent(filePath);
        } else {
             alert("Error: loadContent no est√° definida. Si este archivo es parte de una app, aseg√∫rese de que loadContent() sea global o use el archivo main.js. Intentando navegar a: " + filePath);
        }
    }
    
    // Funci√≥n Guardar y Cerrar (A√±adida)
    function saveAndClose() {
        // Aseguramos que la selecci√≥n y la configuraci√≥n se guarden antes de salir
        saveSelectionToStorage();
        alert("Selecci√≥n y configuraciones guardadas. Volviendo al men√∫ principal.");
        
        // Simular un retorno al men√∫ principal. Asumo que el men√∫ principal es pantalla1.html
        // Si no tienes pantalla1.html, ajusta la ruta.
        loadContent('pantalla1.html'); 
    }
    
    // ===============================================
    // CONFIGURACI√ìN DE DATOS 
    // ===============================================
    const DATA_URL = 'https://djless.github.io/magordito_menu_semanal/calendario_menus_2025/data/menu_db.json';
    const INVENTORY_DATA_URL = 'https://djless.github.io/magordito_menu_semanal/calendario_menus_2025/data/inventario_db.json';
    
    const SELECTION_STORAGE_KEY = 'selectedDishesAndIngredients'; 
    const CUSTOM_ING_STORAGE_KEY = 'customIngredientsConfig'; 
    const STANDARD_ING_STORAGE_KEY = 'standardIngredientsConfig';
    const WIZARD_CONFIG_STORAGE_KEY = 'menuWizardConfig'; 

    let menuData = null;	
    let inventoryData = null; 
    let selectedItems = new Set(); 
    let customIngredients = {}; 
    let standardIngredientsConfig = {};
    let activeWizardConfig = {}; 
    let originalDishNames = new Set(); 
    let inventoryDetailsMap = new Map(); 

    const dishesListContainer = document.getElementById('dishes-list');
    const ingredientsListContainer = document.getElementById('ingredients-list');
    const customIngredientsListContainer = document.getElementById('custom-ingredients-list');
    const loadingMessage = document.getElementById('loading-message');
    const customStatus = document.getElementById('custom-status');

    const CATEGORIES = [
        { value: 'principales', label: 'Principal' },
        { value: 'carbohidratos', label: 'Carbohidrato' },
        { value: 'verduras', label: 'Verdura' }
    ];
    
    const AVAILABILITY_OPTIONS = [1, 2, 3, 4, 5, 6, 7];
    let INGREDIENT_EMOJI_MAP = {}; 
    
    // MAPA DE EMOJIS DE PLATOS (Copiado de pantalla3.html)
    let DISH_EMOJI_MAP = { 
        "Pasta Cl√°sica con Salsa (a elecci√≥n)": "üçù", 
        "Bowl de Arroz, Prote√≠na y Vegetales": "üçö", 
        "Prote√≠na con Papa y Ensalada/Guiso": "ü•î", 
        "Garbanzos y Prote√≠na con Acompa√±amiento": "ü´ò", 
        "Porotos Negros con Prote√≠na y Vegetales": "ü•´", 
        "Hamburguesa Completa (Carne o Vegana)": "üçî", 
        "S√°ndwich de Prote√≠na (Carne o Vegana)": "ü•™", 
        "Plato de Sopa (con Legumbres o Prote√≠na)": "ü•£", 
        "Salteado Vegano Completo": "üçú", 
        "Pizza Casera con Ensalada": "üçï", 
        "Tallarines en Salsa Alfredo con Prote√≠na": "üçù", 
        "Charquic√°n Chileno Tradicional": "üç≤", 
        "Empanada (Pino o Queso) con Ensalada": "ü•ü", 
        "Hummus con Verduras y Pan Pita": "ü•ô", 
        "Ensalada Completa": "ü•ó", 
    };
    
    // ===============================================
    // L√ìGICA DE SINCRONIZACI√ìN PLATO-INGREDIENTE (Mantenida)
    // ===============================================
    
    // Mapa para relacionar Platos con sus Ingredientes v√°lidos (post-filtro)
    let dishIngredientMap = new Map(); 
    // Contador para saber cu√°ntos platos seleccionados requieren un ingrediente
    let ingredientDishCount = new Map(); 

    function buildDishIngredientMap() {
        dishIngredientMap.clear();
        if (!menuData || !menuData.platos_principales) return;

        const allCategories = ['principales', 'carbohidratos', 'verduras'];
        const customIngs = Object.values(customIngredients).filter(item => item.nombre && item.plato_asociado);
        
        menuData.platos_principales.forEach(dish => {
            const dishName = dish.nombre;
            const requiredIngredients = new Set();

            allCategories.forEach(category => {
                // Ingredientes est√°ndar (ya filtrados)
                if (dish[category]) {
                    dish[category].filter(i => i && i !== '-').forEach(ing => requiredIngredients.add(ing));
                }
            });
            
            // Ingredientes personalizados asociados
            customIngs.filter(item => item.plato_asociado === dishName).forEach(item => {
                requiredIngredients.add(item.nombre);
            });

            dishIngredientMap.set(dishName, Array.from(requiredIngredients));
        });
    }
    
    function updateIngredientDishCount(dishName, isAdding) {
        const ingredients = dishIngredientMap.get(dishName);
        if (!ingredients) return;

        ingredients.forEach(ingName => {
            let currentCount = ingredientDishCount.get(ingName) || 0;
            
            if (isAdding) {
                currentCount++;
            } else {
                currentCount = Math.max(0, currentCount - 1);
            }
            
            ingredientDishCount.set(ingName, currentCount);
            
            // Sincronizar la selecci√≥n del ingrediente
            syncIngredientSelection(ingName, currentCount > 0);
        });
    }
    
    function syncIngredientSelection(ingName, shouldBeSelected) {
        const ingElement = document.querySelector(`#ingredients-list .list-item[data-name="${ingName}"]`);
        
        // El ingrediente es personalizado si existe en customIngredients por nombre
        const isCustom = Object.values(customIngredients).some(item => item.nombre === ingName);

        if (!ingElement) {
            // Esto puede pasar si un ingrediente del plato no existe en la lista de ingredientes (e.g., ha sido filtrado)
            return;
        }

        // --- L√≥gica de Sincronizaci√≥n de Selecci√≥n ---
        const isCurrentlySelected = selectedItems.has(ingName);
        
        if (shouldBeSelected && !isCurrentlySelected) {
            // Marcar el ingrediente
            selectedItems.add(ingName);
            ingElement.classList.add('selected');
            const checkbox = ingElement.querySelector('input[type="checkbox"]');
            if (checkbox) checkbox.checked = true;
            
            // Actualizar estado 'selected' del ingrediente personalizado si aplica
            if (isCustom) {
                const customItem = Object.values(customIngredients).find(item => item.nombre === ingName);
                if (customItem) customItem.selected = true;
            }
            
        } else if (!shouldBeSelected && isCurrentlySelected) {
            // Desmarcar el ingrediente solo si no es requerido por *ning√∫n* otro plato activo
            if (ingredientDishCount.get(ingName) === 0) {
                selectedItems.delete(ingName);
                ingElement.classList.remove('selected');
                const checkbox = ingElement.querySelector('input[type="checkbox"]');
                if (checkbox) checkbox.checked = false;
                
                 // Actualizar estado 'selected' del ingrediente personalizado si aplica
                if (isCustom) {
                    const customItem = Object.values(customIngredients).find(item => item.nombre === ingName);
                    if (customItem) customItem.selected = false;
                }
            }
        }
        // No guardar en storage aqu√≠. `toggleSelection` se encargar√° de guardar al final del proceso.
    }

    // -------------------------------------------------------------
    // Funci√≥n de ayuda
    // -------------------------------------------------------------
    function getEmoji(name) {
        return INGREDIENT_EMOJI_MAP[name] || "üçΩÔ∏è";
    }

    // ===============================================
    // L√ìGICA DE SELECCI√ìN GLOBAL (NUEVO)
    // ===============================================

    function selectAllDishes() {
        if (!menuData || !menuData.platos_principales) return;
        
        let changed = false;
        
        // 1. Marcar todos los platos disponibles en selectedItems
        menuData.platos_principales.forEach(dish => {
            const dishName = dish.nombre;
            if (!selectedItems.has(dishName)) {
                selectedItems.add(dishName);
                // 2. Actualizar contador de ingredientes
                updateIngredientDishCount(dishName, true); 
                changed = true;
            }
        });
        
        // No es necesario modificar manualmente los ingredientes personalizados aqu√≠,
        // ya que updateIngredientDishCount() se encarga de agregarlos a selectedItems si son requeridos.

        if (changed) {
            saveSelectionToStorage();
            // Re-renderizar para actualizar el estado visual
            renderDishesList();
            renderIngredientsList();
        }
    }

    function deselectAllDishes() {
        if (!menuData || !menuData.platos_principales) return;
        
        let changed = false;

        // 1. Desmarcar todos los platos disponibles
        menuData.platos_principales.forEach(dish => {
            const dishName = dish.nombre;
            if (selectedItems.has(dishName)) {
                selectedItems.delete(dishName);
                // 2. Descontar ingredientes
                updateIngredientDishCount(dishName, false); 
                changed = true;
            }
        });
        
        // 3. Desmarcar ingredientes personalizados seleccionados manualmente (sin plato activo que los requiera)
        // La l√≥gica de updateIngredientDishCount ya maneja desmarcar los ingredientes (incluidos custom)
        // si su contador llega a 0. Solo aseguramos que se refleje la deselecci√≥n manual de custom.
        Object.values(customIngredients).forEach(item => {
            if (item.selected && item.nombre) {
                 // Si el ingrediente personalizado est√° seleccionado y su contador es 0 (o no existe), lo desmarcamos
                 if ((ingredientDishCount.get(item.nombre) || 0) === 0) {
                     item.selected = false;
                     selectedItems.delete(item.nombre);
                     changed = true;
                 }
            }
        });


        if (changed) {
            saveSelectionToStorage();
            // Re-renderizar para actualizar el estado visual
            renderDishesList();
            renderIngredientsList();
        }
    }

    // ===============================================
    // L√ìGICA DE FILTRADO (Mantenida)
    // ===============================================

    function processDataWithDietFilters(config, menuData, inventoryData) {
        if (!inventoryData || !inventoryData.inventario) return;
        
        // Clonar inventoryData.inventario para re-aplicar filtros cada vez
        const initialInventory = JSON.parse(JSON.stringify(inventoryData.inventario));
        
        const isHipocalorica = config.carbohidratos === 'hipocalorica';
        const userRestrictions = Array.isArray(config.restricciones) ? config.restricciones : ['ninguna'];
        const restrictionsToCheck = ['gluten', 'lactosa', 'frutos_secos', 'mariscos', 'soja', 'huevo'];

        const filteredInventory = initialInventory.filter(item => {
            let isIncluded = true;
            
            // 1. FILTROS DIET√âTICOS
            if (config.tipoDieta === 'vegetariano' && !item.vegetariano) isIncluded = false;
            if (config.tipoDieta === 'vegano' && !item.vegano) isIncluded = false;
            if (config.tipoDieta === 'pescetariano' && !(item.pescetariano || item.vegetariano || item.vegano)) isIncluded = false;
            
            // 2. FILTRO GOURMET
            if (config.estiloGourmet === 'tradicional' && item.gourmet) {
                isIncluded = false;
            }

            // 3. FILTRO DE RESTRICCIONES
            if (!userRestrictions.includes('ninguna')) {
                restrictionsToCheck.forEach(restriction => {
                    if (userRestrictions.includes(restriction) && item[restriction]) {
                        isIncluded = false;
                    }
                });
            }

            // 4. FILTRO DE INGREDIENTES ESPEC√çFICOS A ELIMINAR (No implementado en pantalla5)

            return isIncluded;
        });

        // Aplicar filtros a los platos
        if (menuData && menuData.platos_principales) {
            // Clonar menuData.platos_principales para re-aplicar filtros
            const initialPlatos = JSON.parse(JSON.stringify(menuData.platos_principales.map(d => ({...d})))); 
            const validIngredients = new Set(filteredInventory.map(item => item.nombre));
            const allCategories = ['principales', 'carbohidratos', 'verduras'];

            menuData.platos_principales = initialPlatos.map(dish => {
                 // Crear una copia del plato para modificar sus listas de ingredientes
                const filteredDish = {...dish};

                allCategories.forEach(category => {
                    if (filteredDish[category]) {
                        filteredDish[category] = filteredDish[category].map(ing => {
                            let ingValid = ing && ing !== '-' && validIngredients.has(ing);
                            // Aplicar filtro Hipocal√≥rico
                            if (ingValid && isHipocalorica && category === 'carbohidratos') {
                                return '-';
                            }
                            // Aplicar filtro de ingredientes diet√©ticos
                            return ingValid ? ing : '-';
                        });
                    }
                });
                
                return filteredDish;
            }).filter(dish => {
                if (!dish.principales || dish.principales.length === 0) {
                    return true;
                }
                const validPrimaryCount = dish.principales.filter(ing => ing && ing !== '-').length;
                return validPrimaryCount > 0;
            });
        }

        // Actualizar el inventario para el renderizado (aunque en realidad usamos inventoryDetailsMap)
        // Se mantiene para coherencia, pero el mapeo se hace en loadMenuData
        inventoryData.inventario = filteredInventory;
    }

    // ===============================================
    // L√ìGICA DE ALMACENAMIENTO y SELECCI√ìN (Mantenida)
    // ===============================================

    function saveSelectionToStorage() {
        localStorage.setItem(SELECTION_STORAGE_KEY, JSON.stringify(Array.from(selectedItems)));
        localStorage.setItem(CUSTOM_ING_STORAGE_KEY, JSON.stringify(customIngredients));
        localStorage.setItem(STANDARD_ING_STORAGE_KEY, JSON.stringify(standardIngredientsConfig));
    }

    // `isDish` es una nueva bandera para diferenciar si se toca un plato o un ingrediente
    function toggleSelection(itemName, itemElement, isCustom = false, isDish = false) {
        const isSelected = selectedItems.has(itemName);
        
        if (isDish) {
            // --- L√≥gica para Platos ---
            if (isSelected) {
                // Desmarcar plato
                selectedItems.delete(itemName);
                itemElement.classList.remove('selected');
                updateIngredientDishCount(itemName, false); // Descontar ingredientes
            } else {
                // Marcar plato
                selectedItems.add(itemName);
                itemElement.classList.add('selected');
                updateIngredientDishCount(itemName, true); // Contar ingredientes
            }
        } else {
            // --- L√≥gica para Ingredientes (Manual) ---
            if (isSelected) {
                selectedItems.delete(itemName);
                itemElement.classList.remove('selected');
                if (isCustom) {
                    const customItem = Object.values(customIngredients).find(item => item.nombre === itemName);
                    if (customItem) customItem.selected = false;
                }
            } else {
                selectedItems.add(itemName);
                itemElement.classList.add('selected');
                if (isCustom) {
                    const customItem = Object.values(customIngredients).find(item => item.nombre === itemName);
                    if (customItem) customItem.selected = true;
                }
            }
        }

        saveSelectionToStorage();
    }

    // ===============================================
    // L√ìGICA DE RENDERIZADO (Mantenida)
    // ===============================================
    
    // --- HELPERS PARA CARTAS (Mantenidos) ---
    function createIngredientCardHtml(ingData, isSelected, availabilitySelectHtml) {
        const ingName = ingData.name;
        const typeLabel = ingData.category || ingData.type;
        const emoji = getEmoji(ingData.name); // Usamos el nombre base para el emoji
        
        const checkboxChecked = isSelected ? 'checked' : '';
        const controlsHtml = `
            <div class="ingredient-controls-overlay">
                ${ingData.type === 'standard' || ingData.type === 'custom' ? availabilitySelectHtml : ''}
                <input type="checkbox" data-item-name="${ingName}" ${checkboxChecked}>
            </div>
        `;

        return `
            <div class="ingredient-card" data-id="${ingName}" data-type="${typeLabel}">
                <div class="card-content-wrapper">
                    <span class="card-corner">
                        ${typeLabel.charAt(0)}
                    </span>
                    <div class="card-emoji">${emoji}</div>
                    <div class="card-name">${ingName}</div>
                </div>
                ${controlsHtml}
            </div>
        `;
    }

    function createDishCardHtml(dish, isSelected) {
        const dishName = dish.nombre;
        const dishEmoji = DISH_EMOJI_MAP[dishName] || "üçΩÔ∏è";
        const checkboxChecked = isSelected ? 'checked' : '';
        
        const ingredientsRequired = [];
        if (dish.principales) ingredientsRequired.push(`P: ${dish.principales.filter(i => i && i !== '-').join(', ') || 'N/A'}`);
        if (dish.carbohidratos) ingredientsRequired.push(`C: ${dish.carbohidratos.filter(i => i && i !== '-').join(', ') || 'N/A'}`);
        if (dish.verduras) ingredientsRequired.push(`V: ${dish.verduras.filter(i => i && i !== '-').join(', ') || 'N/A'}`);
        
        const ingredientsListHtml = ingredientsRequired
            .map(text => `<li>${text}</li>`)
            .join('');

        return `
            <div class="result-dish-card" data-dish="${dishName}">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">${dishEmoji}</span>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">${dishName}</p>
                        <ul class="card-ingredients-list">
                            ${ingredientsListHtml || '<li>Ingredientes no especificados</li>'}
                        </ul>
                    </div>
                </div>
                <div class="dish-controls-overlay">
                    <input type="checkbox" data-item-name="${dishName}" ${checkboxChecked}>
                </div>
            </div>
        `;
    }

    // --- RENDERIZADO PRINCIPAL (Mantenida) ---
    
    function renderDishesList() {
        if (!menuData || !menuData.platos_principales) return;
        dishesListContainer.innerHTML = '';
        
        menuData.platos_principales.forEach(dish => {
            const dishName = dish.nombre;
            // La selecci√≥n se basa en selectedItems, que ha sido actualizado por loadMenuData o los botones
            const isSelected = selectedItems.has(dishName);

            const itemDiv = document.createElement('div');
            itemDiv.classList.add('list-item');
            if (isSelected) itemDiv.classList.add('selected');
            itemDiv.setAttribute('data-name', dishName);
            
            itemDiv.innerHTML = createDishCardHtml(dish, isSelected);

            // Listener al click de la carta
            itemDiv.addEventListener('click', (e) => {
                // Prevenir que el click en el checkbox dispare la selecci√≥n dos veces
                if (e.target.type === 'checkbox') return;
                
                // ‚≠êÔ∏è USO DE isDish = true
                toggleSelection(dishName, itemDiv, false, true); 
                
                // Actualizar el estado visual del checkbox
                const checkbox = itemDiv.querySelector('input[type="checkbox"]');
                if (checkbox) checkbox.checked = selectedItems.has(dishName);
            });
            
            // Listener directo al checkbox
            const checkbox = itemDiv.querySelector('input[type="checkbox"]');
            if (checkbox) {
                checkbox.addEventListener('change', () => {
                     // ‚≠êÔ∏è USO DE isDish = true
                    toggleSelection(dishName, itemDiv, false, true);
                    if (selectedItems.has(dishName)) {
                        itemDiv.classList.add('selected');
                    } else {
                        itemDiv.classList.remove('selected');
                    }
                });
            }

            dishesListContainer.appendChild(itemDiv);
        });
    }

    function renderIngredientsList() {
        if (!inventoryData) return;
        
        // 1. Recolectar y clasificar todos los ingredientes (Mantenido)
        const allIngredients = new Map();
        inventoryDetailsMap.forEach((details, ing) => {
            const config = standardIngredientsConfig[ing] || { availability: details.availability || 1 };
            allIngredients.set(ing, { 
                type: 'standard', 
                name: ing, 
                category: details.category, 
                availability: config.availability, 
                ...details
            });
        });

        Object.values(customIngredients).forEach(item => {
            if (item.nombre) {
                const categoryLabel = CATEGORIES.find(c => c.value === item.categoria)?.label;
                allIngredients.set(item.nombre, { 
                    type: 'custom', 
                    name: item.nombre, 
                    category: categoryLabel || 'Custom', 
                    availability: item.availability || 2, 
                });
            }
        });

        const categorizedIngredients = { 
            'Principal': [], 
            'Carbohidrato': [], 
            'Verdura': [], 
            'Custom': [], // Temporalmente aqu√≠
            'No Asignado': [] 
        };
        allIngredients.forEach(ingData => {
            const key = ingData.type === 'custom' ? 'Custom' : (ingData.category || 'No Asignado');
            categorizedIngredients[key].push(ingData);
        });

        Object.values(categorizedIngredients).forEach(list => {
            list.sort((a, b) => a.name.localeCompare(b.name));
        });

        const categoryOrder = [ 
            { key: 'Principal', title: 'Principales ü•©/üçó/üêü' }, 
            { key: 'Carbohidrato', title: 'Carbohidratos üçö/üçù' }, 
            { key: 'Verdura', title: 'Verduras ü•ó/ü•¶' }, 
            { key: 'No Asignado', title: 'Otros / Sin Categor√≠a ‚ùì' },
            { key: 'Custom', title: 'Personalizados (P) ‚ú®' } // Movido al final
        ];

        ingredientsListContainer.innerHTML = '';
        
        // 4. Renderizar categor√≠as y elementos
        categoryOrder.forEach(cat => {
            const ingredients = categorizedIngredients[cat.key];
            if (ingredients.length === 0) return;
            
            // Si es la categor√≠a Custom, no renderizar un header visible en la lista
            // Simplemente renderizamos las tarjetas si existen.
            if (cat.key !== 'Custom') {
                const header = document.createElement('h4');
                header.classList.add('category-header');
                header.textContent = cat.title;
                ingredientsListContainer.appendChild(header);
            }
            
            // Crear contenedor para los ingredientes de la categor√≠a
            const categoryDiv = document.createElement('div');
            // Usar una clase para las categor√≠as, que mantenga el layout de grid de ingredientsListContainer
            categoryDiv.style.display = 'contents'; 

            ingredients.forEach(ingData => {
                const itemName = ingData.name;
                const isCustom = ingData.type === 'custom';
                // La selecci√≥n se basa en selectedItems, que ha sido actualizado por loadMenuData o syncIngredientSelection
                const isSelected = selectedItems.has(itemName); 
                
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('list-item');
                if (isSelected) itemDiv.classList.add('selected');
                itemDiv.setAttribute('data-name', itemName);
                
                let availabilitySelectHtml = '';
                if (ingData.type === 'standard' || ingData.type === 'custom') { // Permitir disponibilidad tambi√©n para custom
                    const currentAvailability = ingData.availability;
                    let selectHtml = `<select class="availability-select" data-item-name="${itemName}">`;
                    AVAILABILITY_OPTIONS.forEach(option => {
                        selectHtml += `<option value="${option}" ${option === currentAvailability ? 'selected' : ''}>${option}</option>`;
                    });
                    selectHtml += `</select>`;
                    availabilitySelectHtml = `
                        <label style="font-size:0.7em; color: var(--text-color);">Disp:</label>
                        ${selectHtml}
                    `;
                }
                
                // USAR LA FUNCI√ìN DE CARTA
                itemDiv.innerHTML = createIngredientCardHtml(ingData, isSelected, availabilitySelectHtml);
                
                // 5. A√±adir Listeners
                
                // Listener de selecci√≥n al CLICK DEL CONTENEDOR DE LA CARTA
                itemDiv.addEventListener('click', (e) => {
                    // Prevenir que el click en el select o checkbox dispare la selecci√≥n dos veces
                    if (e.target.closest('.availability-select') || e.target.type === 'checkbox') return;

                    // ‚≠êÔ∏è USO DE isDish = false (es ingrediente)
                    toggleSelection(itemName, itemDiv, isCustom, false);
                    
                    // Actualizar el estado visual del checkbox
                    const checkbox = itemDiv.querySelector('input[type="checkbox"]');
                    if (checkbox) checkbox.checked = selectedItems.has(itemName);
                });
                
                // Listener directo al checkbox
                const checkbox = itemDiv.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.addEventListener('change', () => {
                        // ‚≠êÔ∏è USO DE isDish = false (es ingrediente)
                        toggleSelection(itemName, itemDiv, isCustom, false);
                        if (selectedItems.has(itemName)) {
                            itemDiv.classList.add('selected');
                        } else {
                            itemDiv.classList.remove('selected');
                        }
                    });
                }


                // Listener para el dropdown de disponibilidad
                const selectElement = itemDiv.querySelector('.availability-select');
                if (selectElement) {
                    selectElement.addEventListener('change', (e) => {
                         if (isCustom) {
                            const customItem = Object.values(customIngredients).find(item => item.nombre === itemName);
                            if (customItem) customItem.availability = parseInt(e.target.value, 10);
                        } else {
                             standardIngredientsConfig[itemName] = standardIngredientsConfig[itemName] || {};
                             standardIngredientsConfig[itemName].availability = parseInt(e.target.value, 10);
                        }
                        saveSelectionToStorage();
                    });
                }
                
                categoryDiv.appendChild(itemDiv);
            });
            
            ingredientsListContainer.appendChild(categoryDiv);
        });
    }

    // ===============================================
    // L√ìGICA DE INGREDIENTES PERSONALIZADOS (Mantenida y Corregida)
    // ===============================================

    function setupCustomIngredients() {
        if (!menuData || !menuData.platos_principales || menuData.platos_principales.length === 0) {
            customStatus.textContent = "No se pudieron cargar los platos para la asociaci√≥n.";
            return;
        }
        customIngredientsListContainer.innerHTML = '';
        const firstDishName = menuData.platos_principales[0]?.nombre || 'Plato N/A';
        
        for (let i = 1; i <= 5; i++) {
            const id = `custom_ing_${i}`;
            if (!customIngredients[id]) {
                customIngredients[id] = { nombre: '', categoria: CATEGORIES[0].value, plato_asociado: firstDishName, selected: false, availability: 2 };
            }
            const item = customIngredients[id];

            const div = document.createElement('div');
            div.classList.add('custom-ingredient-item');
            div.setAttribute('data-id', id);

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.placeholder = `Ingrediente Personalizado ${i}`;
            nameInput.value = item.nombre;
            nameInput.addEventListener('input', (e) => {
                item.nombre = e.target.value.trim();
            });

            const categorySelect = document.createElement('select');
            CATEGORIES.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.value;
                option.textContent = cat.label;
                if (item.categoria === cat.value) option.selected = true;
                categorySelect.appendChild(option);
            });
            categorySelect.addEventListener('change', (e) => {
                item.categoria = e.target.value;
            });
            
            const availabilitySelect = document.createElement('select');
            AVAILABILITY_OPTIONS.forEach(optionValue => {
                const option = document.createElement('option');
                option.value = optionValue;
                option.textContent = `Disp: ${optionValue}`;
                if (item.availability === optionValue) option.selected = true;
                availabilitySelect.appendChild(option);
            });
            availabilitySelect.addEventListener('change', (e) => {
                item.availability = parseInt(e.target.value, 10);
            });

            const dishSelect = document.createElement('select');
            dishSelect.style.flexGrow = '1';
            menuData.platos_principales.forEach(dish => {
                const option = document.createElement('option');
                option.value = dish.nombre;
                option.textContent = dish.nombre;
                if (item.plato_asociado === dish.nombre) option.selected = true;
                dishSelect.appendChild(option);
            });
            dishSelect.addEventListener('change', (e) => {
                item.plato_asociado = e.target.value;
            });

            const applyButton = document.createElement('button');
            applyButton.textContent = 'Aplicar';
            applyButton.style.backgroundColor = '#58a6ff';
            applyButton.style.color = 'white';
            applyButton.style.border = 'none';
            applyButton.style.padding = '5px 10px';
            applyButton.style.borderRadius = '4px';
            applyButton.style.cursor = 'pointer';
            applyButton.addEventListener('click', () => {
                if (item.nombre.length > 0) {
                    saveSelectionToStorage();
                    customStatus.textContent = "Cambios de personalizados aplicados.";
                    customStatus.style.color = '#238636'; 
                    loadMenuData(true); // Recargar las listas
                } else {
                    customStatus.textContent = "El nombre del ingrediente personalizado no puede estar vac√≠o.";
                    customStatus.style.color = '#f75555';
                }
            });

            div.appendChild(nameInput);
            div.appendChild(categorySelect);
            div.appendChild(availabilitySelect);
            div.appendChild(dishSelect);
            div.appendChild(applyButton);
            customIngredientsListContainer.appendChild(div);
        }
    }

    // ===============================================
    // INICIALIZACI√ìN (MODIFICADO para PRIORIZAR localStorage)
    // ===============================================
    async function loadMenuData(reloadListsOnly = false) {
        if (!reloadListsOnly) {
             loadingMessage.textContent = 'Cargando datos...';
             // Inicializar los contadores al cargar la data
             ingredientDishCount.clear(); 
        }

        try {
            // 1. Cargar datos desde localStorage (PRIORITARIO) o desde GitHub (Fallback)
            
            // --- Cargar Inventario ---
            const localInventario = localStorage.getItem('inventarioData');
            if (localInventario) {
                // main.js guarda SOLO el array de √≠tems, pantalla5 espera el objeto {inventario: [...]}
                inventoryData = { inventario: JSON.parse(localInventario) }; 
                console.log("Inventario cargado desde LocalStorage (con datos de logros).");
            } else if (!inventoryData) {
                const inventoryResponse = await fetch(INVENTORY_DATA_URL);
                if (!inventoryResponse.ok) throw new Error(`HTTP error! status: ${inventoryResponse.status} al cargar inventario`);
                inventoryData = await inventoryResponse.json(); // Carga el objeto completo {inventario: [...]}
                console.log("Inventario cargado desde GitHub.");
            }
            
            // --- Cargar Men√∫ ---
            const localMenu = localStorage.getItem('menuData');
            if (localMenu) {
                // main.js guarda el objeto completo {platos_principales: [...]}
                menuData = JSON.parse(localMenu); 
                console.log("Men√∫ cargado desde LocalStorage (con platos de logros).");
            } else if (!menuData) {
                const menuResponse = await fetch(DATA_URL);
                if (!menuResponse.ok) throw new Error(`HTTP error! status: ${menuResponse.status} al cargar men√∫`);
                menuData = await menuResponse.json(); // Carga el objeto completo
                console.log("Men√∫ cargado desde GitHub.");
            }
            
            // 2. Poblar mapa de Emojis, detalles y nombres originales
            originalDishNames = new Set(menuData.platos_principales.map(dish => dish.nombre)); 
            
            inventoryDetailsMap.clear();
            INGREDIENT_EMOJI_MAP = {};
            if (inventoryData && inventoryData.inventario) {
                inventoryData.inventario.forEach(item => {
                    if (item.nombre && item.emoji) {
                        INGREDIENT_EMOJI_MAP[item.nombre] = item.emoji;
                    }
                    // ‚≠êÔ∏è CORRECCI√ìN: Usar la propiedad 'categoria' del JSON del inventario para determinar
                    // el label de la categor√≠a en may√∫scula inicial para el renderizado.
                    let category = 'No Asignado';
                    if (item.categoria === 'principal') category = 'Principal';
                    else if (item.categoria === 'carbohidrato') category = 'Carbohidrato';
                    else if (item.categoria === 'verdura') category = 'Verdura';

                    inventoryDetailsMap.set(item.nombre, { 
                        category: category, 
                        vegetariano: item.vegetariano, 
                        vegano: item.vegano, 
                        gourmet: item.gourmet,
                        availability: item.cantidad_disponible || 1
                    });
                });
            }
            

            // 3. Cargar configuraci√≥n de filtros
            const storedWizardConfig = localStorage.getItem(WIZARD_CONFIG_STORAGE_KEY);
            activeWizardConfig = storedWizardConfig ? JSON.parse(storedWizardConfig) : {
                tipoDieta: 'normal',
                estiloGourmet: 'cualquiera',
                carbohidratos: 'normal',
                restricciones: ['ninguna']
            };

            // 4. Aplicar filtros a una copia de los datos
            const filteredMenuData = JSON.parse(JSON.stringify(menuData));
            const filteredInventoryData = JSON.parse(JSON.stringify(inventoryData));
            const tempMenuData = { platos_principales: filteredMenuData.platos_principales };
            const tempInventoryData = { inventario: filteredInventoryData.inventario };
            
            // Aplicar filtros a los datos temporales
            processDataWithDietFilters(activeWizardConfig, tempMenuData, tempInventoryData);
            menuData.platos_principales = tempMenuData.platos_principales;
            inventoryData.inventario = tempInventoryData.inventario;


            // 5. Cargar selecci√≥n y configs
            const storedSelection = localStorage.getItem(SELECTION_STORAGE_KEY);
            // La selecci√≥n debe ser la de los √≠tems que el usuario ha querido mantener
            selectedItems = new Set(storedSelection ? JSON.parse(storedSelection) : []); 
            
            const storedCustomConfig = localStorage.getItem(CUSTOM_ING_STORAGE_KEY);
            customIngredients = storedCustomConfig ? JSON.parse(storedCustomConfig) : {};
            
            const storedStandardConfig = localStorage.getItem(STANDARD_ING_STORAGE_KEY);
            standardIngredientsConfig = storedStandardConfig ? JSON.parse(storedStandardConfig) : {};


            // Forzar la re-inclusi√≥n de custom ingredients si tienen nombre.
            Object.keys(customIngredients).forEach(key => {
                const customItem = customIngredients[key];
                if (customItem.selected && customItem.nombre) {
                    selectedItems.add(customItem.nombre);
                } else if (!customItem.availability) {
                    customItem.availability = 2; // Asegurar valor por defecto
                }
            });

            // ‚≠êÔ∏è 6. Inicializar Mapa Plato-Ingrediente y Contador de Platos por Ingrediente
            buildDishIngredientMap();
            ingredientDishCount.clear(); // Limpiar antes de re-contar
            
            // Contar cu√°ntos platos seleccionados hay para cada ingrediente
            selectedItems.forEach(itemName => {
                // Si el √≠tem es un plato (est√° en el mapa de platos/ingredientes), actualizamos el contador.
                // Es importante comprobar si el plato a√∫n existe en los datos filtrados.
                if (dishIngredientMap.has(itemName)) { 
                    updateIngredientDishCount(itemName, true);
                } else if (originalDishNames.has(itemName)) {
                    // Si el plato estaba seleccionado pero fue filtrado, lo removemos
                    selectedItems.delete(itemName);
                }
            });
            
            // Forzar la selecci√≥n de ingredientes necesarios por los platos seleccionados.
            ingredientDishCount.forEach((count, ingName) => {
                if (count > 0) {
                    selectedItems.add(ingName);
                } 
                // Si el contador es 0, syncIngredientSelection ya se encarg√≥ de desmarcarlo si era requerido
                // por un plato que fue desmarcado o filtrado.
            });


            // ‚≠êÔ∏è 7. Limpieza final de configuraci√≥n de ingredientes est√°ndar (mantenida)
            const validIngredientNames = new Set(inventoryData.inventario.map(item => item.nombre));
            
            Object.keys(standardIngredientsConfig).forEach(ing => {
                 if (!validIngredientNames.has(ing)) {
                     delete standardIngredientsConfig[ing];
                 }
            });
            
            saveSelectionToStorage(); // Guardar el nuevo estado de selecci√≥n forzada
            
            // 8. Renderizar
            setupCustomIngredients();
            loadingMessage.textContent = '';	
            renderDishesList();
            renderIngredientsList(); 

        } catch (error) {
            loadingMessage.style.color = '#f75555';
            loadingMessage.textContent = `ERROR: ${error.message}`;
            console.error("Fallo la carga de datos:", error);
        }
    }
    
    // Llamada de inicializaci√≥n
    loadMenuData();
</script>
</body>
</html>
