<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Men√∫ Semanal (Pantalla 4 - Estilo Naipe)</title>
    
    <link rel="stylesheet" href="../assets/css/card_styles.css">
    
    <style>
        /* ATENCI√ìN: Estos estilos son para la estructura de la pantalla 4. */
        body {
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 5px; 
            text-align: center;
            font-size: 0.8em;
            height: 100vh;
            margin: 0;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
        }
        
        /* Variables necesarias de pantalla3 para el estilo de los naipes de plato */
        :root {
            /* Se asume que card_styles.css ya tiene la base de los .card, pero estas variables ayudan al carrusel */
            --dish-card-width: 80px;
            --dish-card-aspect-ratio: calc(70 / 49);
            --dish-card-calculated-height: calc(var(--dish-card-width) * var(--dish-card-aspect-ratio));
            --lift-amount: 20px;
            --success-color: #238636;
        }

        h2 {
            font-size: 1.1em; 
            margin-bottom: 5px;
        }
        
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        #randomize-button {
            background-color: #238636;
            color: white;
            border: none;
            padding: 5px 10px; 
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        #randomize-button:hover {
            background-color: #2ea043;
        }
        
        .control-label {
            font-weight: 400;
            margin-right: 5px;
        }
        
        #consecutive-meals-select {
            padding: 4px 8px; 
            border-radius: 6px;
            border: 1px solid #30363d;
            background-color: #161b22;
            color: #c9d1d9;
            font-weight: 600;
            cursor: pointer;
        }

        /* Estilo para el nuevo toggle (1 o 2 comidas) */
        #meals-per-day-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #1f242c;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }
        
        /* Estilo para el nuevo control del checkbox (Platos Creados) */
        #use-created-dishes-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #1f242c;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }

        /* Estilo del carrusel/mano de naipes (similar a pantalla3.html) */
        #dish-hand-carousel {
            height: calc(var(--dish-card-calculated-height) + var(--lift-amount) + 20px); 
            display: flex;
            gap: 0px; 
            overflow-x: auto; 
            padding: 10px;
            border-radius: 8px;
            background-color: #161b22;
            align-items: flex-end; 
            flex-shrink: 0; 
            position: relative; 
            justify-content: flex-start;
            margin-top: 10px; 
            scrollbar-width: thin; 
            /* Ocultar por defecto, JS lo muestra en modo creado */
            display: none; 
        }
        
        /* Estilo del naipe de la mano (para que se vea como plato creado y se 'levante' al hacer hover) */
        #dish-hand-carousel .card {
            flex: 0 0 var(--dish-card-width);
            width: var(--dish-card-width); 
            height: 0;
            padding-bottom: var(--dish-card-calculated-height); 
            border: 2px solid var(--success-color); /* Borde verde para distinguirlo de la mano */
            margin-top: var(--lift-amount); 
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
            cursor: grab;
            margin-right: -15px; /* Superposici√≥n ligera */
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.2s, opacity 0.3s, margin-top 0.2s, margin-right 0.2s;
        }
        
        #dish-hand-carousel .card:hover {
            transform: translateY(calc(-1 * var(--lift-amount))) !important; 
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.6), 0 0 10px var(--success-color);
        }

        /* Contenedor principal de 2 columnas para los D√çAS (4 naipes por fila) */
        #drop-zones-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2 D√çAS por fila */
            gap: 5px; /* Espacio entre los d√≠as */
            width: 99%;
            max-width: 900px;
            margin: 0px auto;
            padding: 0px;
            border: 1px solid #30363d;
            border-radius: 1px;
            background-color: #161b22;
            flex-grow: 1; 
            overflow-y: auto; 
            overflow-x: hidden;
            min-height: 0; 
        }

        /* Contenedor (drop-zone) para CADA D√çA */
        .drop-zone {
            background-color: #1f242c;
            border: 2px solid #30363d;
            border-radius: 4px;
            min-height: 70px; 
            width: 100%; /* Ocupa el 100% de su columna en el grid */
            overflow: visible;
            padding: 1px;
            transition: border-color 0.2s, background-color 0.2s;
            
            /* === Configuraci√≥n Flex para 2 tarjetas horizontales (IZQUIERDA/DERECHA) === */
            display: flex;
            flex-direction: row; /* Asegura el flujo horizontal */
            flex-wrap: wrap; 
            justify-content: space-around; /* Distribuye las 2 cartas */
            align-items: flex-start;
            position: relative;
            padding-top: 25px; /* Espacio para el label pegado */
        }
        
        /* Resalte de zona de drop */
        .drop-zone.drag-over {
            border-color: #58a6ff;
            background-color: #242931;
        }

        .zone-label {
            font-weight: 600;
            color: #58a6ff;
            font-size: 0.8em; 
            width: 100%; /* El label siempre ocupa todo el ancho */
            text-align: left;
            padding-left: 5px;
            position: absolute; /* POSICI√ìN FIJA DENTRO DEL CONTENEDOR DE D√çA */
            top: 0;
            left: 0;
            background-color: #1f242c;
            z-index: 5;
            padding-top: 1px; 
            padding-bottom: 2px;
            border-bottom: 1px solid #30363d;
        }
        
        /* Estilos espec√≠ficos para la tarjeta dentro del contenedor de 2 columnas */
        .drop-zone .card, .drop-zone .placeholder {
            /* Los estilos de 'margin' deben asegurar el espacio entre ellas */
            margin: 5px 3px 5px 3px; 
            /* Se mantiene el width definido en card_styles.css (ej. 80px) */
        }
        
        /* A√ëADIDO: Asegura que todas las tarjetas en las zonas de drop tengan el cursor de movimiento */
        .drop-zone .card {
            cursor: grab; 
        }

        /* Responsive para la estructura */
        @media (max-width: 650px) {
            #drop-zones-container {
                grid-template-columns: repeat(2, 1fr);
                max-width: 400px;
            }
        }
        
        /* Placeholder con estilos de tarjeta para mantener el layout de 2 columnas */
        .placeholder {
            /* ESTILOS DE card_styles.css */
            background-color: #58a6ff;
            border: 1px dashed #58a6ff;
            opacity: 0.15;
            transition: opacity 0.3s;
            cursor: default;
        }

        .card.dragging {
            opacity: 0.1;
        }
        
    </style>
</head>
<body>

    <h2>Men√∫ semanal</h2>
    
    <div id="controls">
        <label for="consecutive-meals-select" class="control-label">Cocino para</label>
        <select id="consecutive-meals-select">
            <option value="1">1 comida seguida</option>
            <option value="2" selected>2 comidas seguidas</option>
            <option value="3">3 comidas seguidas</option>
            <option value="4">4 comidas seguidas</option>
            <option value="5">5 comidas seguidas</option>
            <option value="6">6 comidas seguidas</option>
        </select>
        
        <div id="meals-per-day-control">
            <label for="meals-per-day-toggle" class="control-label">1 o 2 Comidas/D√≠a</label>
            <input type="checkbox" id="meals-per-day-toggle" checked>
        </div>
        
        <div id="use-created-dishes-control">
            <label for="use-created-dishes-checkbox" class="control-label">Usar Platos Creados üç≥</label>
            <input type="checkbox" id="use-created-dishes-checkbox">
        </div>
        
        <button id="randomize-button">Randomizar Platos</button>
    </div>

    <div id="loading-message" style="color: #58a6ff; margin-top: 5px;">Cargando men√∫ desde GitHub...</div>
    
    <div id="dish-hand-carousel" style="display: none;">
        </div>

    <div id="drop-zones-container">
        <div class="drop-zone" data-day="Lunes">
            <div class="zone-label">Lunes</div>
            <div class="card" draggable="true" data-dish="Lasa√±a">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">üçù</span>
                        <div class="card-secondary-emojis">üßÖüçÖ</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Lasa√±a de Carne</p>
                        <ul class="card-ingredients-list">
                            <li>Carne Molida</li>
                            <li>Pasta Lasa√±a</li>
                            <li>Tomate</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="card" draggable="true" data-dish="Sopa">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">üç≤</span>
                        <div class="card-secondary-emojis">ü•ïü•î</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Sopa de Verduras</p>
                        <ul class="card-ingredients-list">
                            <li>Pollo</li>
                            <li>Papa</li>
                            <li>Zanahoria</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="drop-zone" data-day="Martes">
            <div class="zone-label">Martes</div>
            <div class="card" draggable="true" data-dish="Fideos">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">üçú</span>
                        <div class="card-secondary-emojis">üßÄüå∂Ô∏è</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Fideos con Queso</p>
                        <ul class="card-ingredients-list">
                            <li>Leche</li>
                            <li>Fideos</li>
                            <li>Queso</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="card" draggable="true" data-dish="Cazuela">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">ü•£</span>
                        <div class="card-secondary-emojis">üåΩüéÉ</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Cazuela de Pollo</p>
                        <ul class="card-ingredients-list">
                            <li>Pollo</li>
                            <li>Zapallo</li>
                            <li>Choclo</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="drop-zone" data-day="Mi√©rcoles">
            <div class="zone-label">Mi√©rcoles</div>
        </div>
        <div class="drop-zone" data-day="Jueves">
            <div class="zone-label">Jueves</div>
        </div>
        <div class="drop-zone" data-day="Viernes">
            <div class="zone-label">Viernes</div>
        </div>
        <div class="drop-zone" data-day="S√°bado">
            <div class="zone-label">S√°bado</div>
        </div>
        <div class="drop-zone" data-day="Domingo">
            <div class="zone-label">Domingo</div>
        </div>
    </div>

    <script>
        // ===============================================
        // CONFIGURACI√ìN DE DATOS
        // ===============================================
        // Se mantiene la URL est√°tica para la primera carga si no hay LocalStorage
        const DATA_URL = 'https://djless.github.io/magordito_menu_semanal/calendario_menus_2025/data/menu_db.json';
        const INVENTORY_DATA_URL = 'https://djless.github.io/magordito_menu_semanal/calendario_menus_2025/data/inventario_db.json'; 
        
        let CARDS_PER_ZONE = 2; 
        const DAYS_COUNT = 7;
        let TOTAL_CARDS = CARDS_PER_ZONE * DAYS_COUNT;
        
        let allDishes = []; 
        let menuData = null; 
        let allowedDishes = [];
        const MENU_STORAGE_KEY = 'menuData'; 
        const SELECTION_STORAGE_KEY = 'selectedDishesAndIngredients'; 
        const CUSTOM_ING_STORAGE_KEY = 'customIngredientsConfig'; 
        const STANDARD_ING_STORAGE_KEY = 'standardIngredientsConfig'; // Nueva clave para la disponibilidad est√°ndar
        const CREATED_DISHES_STORAGE_KEY = 'dishCreator_successfullyCreatedDishes';
        let customIngredients = {}; // Inventario consolidado
        let selectedComponentsSet = new Set(); 
        let INGREDIENT_EMOJI_MAP = {}; 

        const container = document.getElementById('drop-zones-container');
        const randomizeButton = document.getElementById('randomize-button');
        const allZones = Array.from(document.querySelectorAll('.drop-zone'));
        const loadingMessage = document.getElementById('loading-message');
        const consecutiveMealsSelect = document.getElementById('consecutive-meals-select');
        const mealsPerDayToggle = document.getElementById('meals-per-day-toggle'); 
        
        const useCreatedDishesCheckbox = document.getElementById('use-created-dishes-checkbox');
        const dishHandCarousel = document.getElementById('dish-hand-carousel');
        let createdDishes = [];

        // ===============================================
        // DRAG & DROP VARIABLES GLOBALES (MOVER Y COPIAR)
        // ===============================================
        let draggedCard = null; // La tarjeta real (solo para modo MOVER)
        let placeholder = null; 
        let lastRectMap = new Map(); // Mapa para las posiciones iniciales (FLIP: First)
        
        // --- Variables de Throttling (Optimizaci√≥n de Fluidez) ---
        let isUpdating = false; 
        let lastDragEventData = { zone: null, clientX: 0, clientY: 0 }; 
        // ---------------------------------------------------------


        // ===============================================
        // FUNCIONES DE UTILIDAD D&D (FLIP)
        // ===============================================

        function getAllCards(includeHand = false) {
            let selector = '.drop-zone .card:not(.placeholder)';
            if (includeHand) {
                selector += ', #dish-hand-carousel .card:not(.placeholder)';
            }
            // Obtiene todas las tarjetas (.card) en las zonas, excluyendo el placeholder.
            return Array.from(document.querySelectorAll(selector));
        }

        function registerLiveTransforms(includePlaceholder = true) {
            // FLIP: Captura las posiciones de todas las tarjetas visibles (FIRST).
            lastRectMap.clear();
            const allCards = getAllCards(useCreatedDishesCheckbox.checked); // Incluir mano si aplica
            allCards.forEach(card => {
                if (window.getComputedStyle(card).display !== 'none') {
                    lastRectMap.set(card, card.getBoundingClientRect());
                }
            });
            // Tambi√©n registramos la posici√≥n del placeholder
            if (includePlaceholder && placeholder && placeholder.parentNode) {
                 lastRectMap.set(placeholder, placeholder.getBoundingClientRect());
            }
        }

        function applyFLIPAnimation() {
             // 1. INVERT (Mover visualmente al estado 'FIRST' capturado antes del cambio de DOM)
            // Recoger todas las tarjetas y el placeholder que participaron en la reordenaci√≥n.
            const allElements = Array.from(document.querySelectorAll('.card:not([style*="display: none"]), .placeholder'));
            
            allElements.forEach(element => {
                // Si la tarjeta est√° siendo arrastrada (draggedCard), la ignoramos
                if (element === draggedCard) return;

                const firstRect = lastRectMap.get(element); 
                if (!firstRect) return; // Si no se registr√≥ la posici√≥n inicial, ignorar

                const lastRect = element.getBoundingClientRect(); // LAST

                const deltaX = firstRect.left - lastRect.left;
                const deltaY = firstRect.top - lastRect.top;

                if (deltaX !== 0 || deltaY !== 0) {
                    // INVERT: Mover al "FIRST"
                    element.style.transition = 'none';
                    element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

                    // PLAY: Aplicar transici√≥n y restaurar posici√≥n (animaci√≥n de movimiento)
                    requestAnimationFrame(() => {
                        element.style.transition = 'transform 0.3s ease-in-out';
                        element.style.transform = '';
                    });
                }
            });
        }

        function clearLiveTransforms() {
            // Limpia los estilos de transici√≥n y las variables globales.
            const allCards = getAllCards(true);
            allCards.forEach(card => card.style.transition = '');
            
            if (draggedCard) {
                draggedCard.classList.remove('dragging');
                draggedCard.style.display = ''; 
                draggedCard.style.transform = ''; 
                
                // Si la tarjeta ven√≠a de la mano y no fue dropeada, hay que reinsertarla.
                if (!draggedCard.parentNode) {
                    // Reinsertar en la mano al final
                    dishHandCarousel.appendChild(draggedCard);
                }
            }
            if (placeholder && placeholder.parentNode) {
                placeholder.remove();
            }
            
            lastRectMap.clear();
            draggedCard = null;
            placeholder = null;
            allZones.forEach(zone => zone.classList.remove('drag-over'));
            dishHandCarousel.classList.remove('drag-over');
        }

        function getDragAfterElement(container, x) {
            // Determina la tarjeta o placeholder despu√©s de la cual se debe insertar el placeholder.
            const elements = Array.from(container.children).filter(
                element => element !== draggedCard && element !== placeholder && element.classList && (element.classList.contains('card') || element.classList.contains('placeholder'))
            );
            
            if (elements.length === 0) return null; 

            return elements.reduce((closest, child) => {
                const rect = child.getBoundingClientRect();
                const center = rect.left + rect.width / 2;
                const offset = x - center;

                // Solo si el puntero est√° ANTES del centro del elemento.
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        /**
         * Reordena el DOM de todas las zonas para lograr el efecto cascada en vivo.
         */
        function liveReorderAndFlip(currentZone, clientX) {
            if (!placeholder || !draggedCard) return; // Asegurarse de que estamos en modo MOVER
            
            // 1. FIRST: Capture positions before any DOM changes.
            registerLiveTransforms();

            // 2. Local Reorder: Insert placeholder in the CURRENT zone.
            if (placeholder.parentNode) placeholder.remove(); 
            
            const afterElement = getDragAfterElement(currentZone, clientX);
            
            if (afterElement == null) {
                currentZone.appendChild(placeholder);
            } else {
                currentZone.insertBefore(placeholder, afterElement);
            }
            
            // Si es modo MOVER (lo cual siempre es ahora si llegamos aqu√≠), reordenar globalmente.
            
            // 3. Global Reorder
            // A. Obtener la secuencia global *actual* del DOM.
            // Incluimos la mano para que la tarjeta arrastrada se pueda mover a la mano y viceversa.
            let allDropAreas = [...allZones];
            if (useCreatedDishesCheckbox.checked) {
                allDropAreas.push(dishHandCarousel);
            }
            
            let currentGlobalSequence = allDropAreas.flatMap(zone => 
                Array.from(zone.children).filter(el => 
                    el.classList && (el.classList.contains('card') || el.classList.contains('placeholder')) && el !== draggedCard
                )
            );
            
            // B. Reconstrucci√≥n de las zonas: Limpiar y re-agregar.
            allZones.forEach(z => {
                const label = z.querySelector('.zone-label');
                if(label) label.remove();
                z.innerHTML = '';
                if(label) z.appendChild(label); 
            });
            // Limpiar la mano tambi√©n para reconstruir su contenido
            dishHandCarousel.innerHTML = ''; 

            // C. Apendizar elementos a sus nuevas zonas seg√∫n CARDS_PER_ZONE
            currentGlobalSequence.forEach((el, index) => {
                const targetZoneIndex = Math.floor(index / CARDS_PER_ZONE);
                
                // Los elementos que exceden el l√≠mite de drop zones (7 d√≠as * CARDS_PER_ZONE)
                // deben regresar a la mano si estamos en modo creado.
                if (targetZoneIndex < DAYS_COUNT) {
                    const targetZone = allZones[targetZoneIndex];
                    if (targetZone) {
                        targetZone.appendChild(el);
                    }
                } else if (useCreatedDishesCheckbox.checked) {
                    // Si se excede el l√≠mite de d√≠as, y estamos en modo creado, va a la mano (el "extra").
                    dishHandCarousel.appendChild(el);
                }
            });


            // 4. INVERT & PLAY: Animar
            applyFLIPAnimation();
        }
        
        // --- Funci√≥n de Throttling ---
        function processDragOverUpdate() {
            // Solo procesa si estamos moviendo una tarjeta (draggedCard existe) o copiando (placeholder existe)
            if (lastDragEventData.zone) {
                liveReorderAndFlip(lastDragEventData.zone, lastDragEventData.clientX); 
            }
            isUpdating = false; // Resetear la bandera para permitir el siguiente frame
        }
        // ------------------------------

        // ===============================================
        // L√ìGICA DE DATOS Y CONSUMO DE INGREDIENTES
        // ===============================================
        
        function getRandomElement(arr) {
            if (!arr || arr.length === 0 || (arr.length === 1 && arr[0] === "-")) return 'N/A';
            const randomIndex = Math.floor(Math.random() * arr.length);
            return arr[randomIndex];
        }

        function getDishEmoji(dishName, selectedPrincipal) {
            if (INGREDIENT_EMOJI_MAP[dishName]) {
                return INGREDIENT_EMOJI_MAP[dishName];
            }
            const principalObject = menuData?.platos_principales.find(p => p.nombre === dishName);
            if (principalObject?.principales?.[0] && INGREDIENT_EMOJI_MAP[principalObject.principales[0]]) {
                return INGREDIENT_EMOJI_MAP[principalObject.principales[0]];
            }
            return "üçΩÔ∏è";
        }

        /**
         * Selecciona los componentes de un plato, verifica su disponibilidad
         * en el inventario de trabajo y consume 1 unidad de cada uno si est√° disponible.
         * @param {string} dishName - Nombre del plato.
         * @param {boolean} shouldConsume - Si debe consumir los ingredientes.
         * @param {Object} workingInventory - Referencia al inventario de trabajo (ingName: count).
         * @returns {Object} { isAvailable: boolean, details: Object }
         */
        function selectDishComponentsAndConsume(dishName, shouldConsume = false, workingInventory = null) {
            if (!menuData || !menuData.platos_principales) {
                return { isAvailable: false, details: null };
            }

            const dishObject = menuData.platos_principales.find(p => p.nombre === dishName);
            if (!dishObject) {
                return { isAvailable: false, details: null };
            }

            let principales = (dishObject.principales || []).filter(i => i && i !== '-');
            let carbohidratos = (dishObject.carbohidratos || []).filter(i => i && i !== '-');
            let verduras = (dishObject.verduras || []).filter(i => i && i !== '-');

            // 1. FILTRO DE ACTIVACI√ìN/SELECCI√ìN (MANTIENE SOLO LOS SELECCIONADOS)
            if (selectedComponentsSet.size > 0) {
                principales = principales.filter(ing => selectedComponentsSet.has(ing));
                carbohidratos = carbohidratos.filter(ing => selectedComponentsSet.has(ing));
                verduras = verduras.filter(ing => selectedComponentsSet.has(ing));
            }

            // 2. FILTRO DE DISPONIBILIDAD (Quantity > 0 O NO OMITIDO) - Usa el inventario *de la semana*
            // Si el ingrediente NO est√° en el inventario consolidado, es porque:
            // a) No es un ingrediente contado.
            // b) No est√° seleccionado/activado.
            // Dado que el filtro de activaci√≥n (Paso 1) ya se aplic√≥, solo necesitamos el chequeo de cantidad.
            
            // Si alg√∫n componente esencial ya est√° en 0 en el inventario de la semana, el plato no puede ser generado.
            const initialCheck = [...principales, ...carbohidratos, ...verduras].every(ing => {
                 const status = workingInventory[ing];
                 if (status === undefined || status === true) return true; // No es un ingrediente contado o est√° marcado como disponible (true)
                 if (typeof status === 'number') return status > 0;
                 if (status === false) return false; // Omitido
                 return true;
            });

            if (!initialCheck || principales.length === 0) {
                 return { isAvailable: false, details: null };
            }


            // 3. Selecci√≥n de componentes al azar
            const selectedPrincipal = getRandomElement(principales);
            const selectedCarbohidrato = getRandomElement(carbohidratos);
            const selectedVerdura = getRandomElement(verduras);

            const finalComponents = [selectedPrincipal, selectedCarbohidrato, selectedVerdura].filter(i => i && i !== 'N/A');

            // 4. CONSUMO (Solo en modo Randomize)
            if (shouldConsume && workingInventory) {
                // Verificar la disponibilidad final antes de consumir (evita problemas con elementos consecutivos)
                const allAvailableForConsumption = finalComponents.every(ing => {
                    const count = workingInventory[ing];
                    // Si no est√° en el inventario contado o no es un n√∫mero, se asume disponible para consumo (o no necesita consumo)
                    if (count === undefined || typeof count !== 'number') return true; 
                    return count > 0;
                });

                if (!allAvailableForConsumption) {
                    // Uno de los componentes necesarios se agot√≥.
                    return { isAvailable: false, details: null };
                }

                // CONSUMIR
                finalComponents.forEach(ing => {
                    if (workingInventory[ing] !== undefined && typeof workingInventory[ing] === 'number') {
                        workingInventory[ing] -= 1; 
                        console.log(`Consumo de ${ing}: Restante ${workingInventory[ing]}`);
                    }
                });
            }

            return {
                isAvailable: true,
                details: {
                    principal: selectedPrincipal,
                    carbohidrato: selectedCarbohidrato,
                    verdura: selectedVerdura,
                    emojiPrincipal: getDishEmoji(dishName, selectedPrincipal)
                }
            };
        }
        
        function getRandomDishes(count, workingInventory) {
            const consecutiveCount = parseInt(consecutiveMealsSelect.value, 10);
            const selectedDishes = [];
            
            // Crear una copia del array de platos permitidos para el ciclo de randomizaci√≥n
            const dishesToSelectFrom = [...allowedDishes]; 

            for (let i = 0; i < count; i++) {
                
                let attempts = dishesToSelectFrom.length * 2; 
                let selectedDishData = null;
                
                while (attempts > 0) {
                    if (dishesToSelectFrom.length === 0) break;
                    
                    // 1. Pick a random dish name from the allowed list
                    let randomDishIndex = Math.floor(Math.random() * dishesToSelectFrom.length);
                    let candidateDishName = dishesToSelectFrom[randomDishIndex];
                    
                    // 2. Intentar seleccionar componentes y CONSUMIR el inventario
                    const dishDetailsResult = selectDishComponentsAndConsume(candidateDishName, true, workingInventory); 
                    
                    if (dishDetailsResult.isAvailable) {
                        selectedDishData = {
                            name: candidateDishName, 
                            details: dishDetailsResult.details 
                        };
                        
                        // Remover de la lista de candidatos para no repetir (excepto por consecutivo)
                        dishesToSelectFrom.splice(randomDishIndex, 1);
                        break; 
                    } else {
                         // Plato no disponible (ingrediente agotado) -> remover permanentemente del pool
                        dishesToSelectFrom.splice(randomDishIndex, 1);
                    }
                    
                    attempts--;
                }

                if (!selectedDishData) {
                    // No se pudo encontrar un plato disponible, terminar.
                    break;
                }
                
                selectedDishes.push(selectedDishData);
                
                // Manejar platos consecutivos
                if ((i % CARDS_PER_ZONE) === 0 && (i + 1) < count) {
                    for (let j = 1; j < consecutiveCount && (i + j) < count; j++) {
                        // Para comidas consecutivas, se reutilizan los mismos detalles (ya consumidos)
                        selectedDishes.push(selectedDishData); 
                    }
                    i += consecutiveCount - 1; 
                }
            }
            return selectedDishes;
        }

        /**
         * Crea el HTML de la tarjeta, adaptado para recibir la estructura de plato randomizado
         * ({name, details}) o el objeto de plato creado ({nombre, principales, ...}).
         */
        function createDishCardHtml(dishData) {
            
            let isRandomized = false;
            let dishName, details, ingredientsList;
            
            // Caso 1: Plato desde Randomizado ({name: 'dish', details: {principal: '...', ...}})
            if (dishData.name && dishData.details) {
                isRandomized = true;
                dishName = dishData.name;
                details = dishData.details;
                ingredientsList = [details.principal, details.carbohidrato, details.verdura]
                    .filter(i => i && i !== 'N/A');
                
            } 
            // Caso 2: Plato desde el Carrusel Creado (Objeto de plato completo)
            else {
                dishName = dishData.nombre; 
                const principales = dishData.principales || [];
                const carbohidratos = dishData.carbohidratos || [];
                const verduras = dishData.verduras || [];
                
                const mainIngredientName = principales[0];
                const mainEmoji = INGREDIENT_EMOJI_MAP[mainIngredientName] || 'üçΩÔ∏è'; 
                
                details = {
                    principal: principales[0] || 'N/A',
                    carbohidrato: carbohidratos[0] || 'N/A',
                    verdura: verduras[0] || 'N/A',
                    emojiPrincipal: mainEmoji
                };
                
                ingredientsList = [
                    ...principales, ...carbohidratos, ...verduras
                ].filter(i => i && i !== 'N/A');
            }

            let secondaryEmojis = '';
            if (details.carbohidrato && details.carbohidrato !== 'N/A' && INGREDIENT_EMOJI_MAP[details.carbohidrato]) {
                secondaryEmojis += INGREDIENT_EMOJI_MAP[details.carbohidrato];
            }
            if (details.verdura && details.verdura !== 'N/A' && INGREDIENT_EMOJI_MAP[details.verdura]) {
                secondaryEmojis += INGREDIENT_EMOJI_MAP[details.verdura];
            }

            const card = document.createElement('div');
            card.className = 'card';
            card.draggable = true;
            card.setAttribute('data-dish', dishName);
            if (!isRandomized) { 
                card.setAttribute('data-dish-json', JSON.stringify(dishData));
            }


            const ingredientsListHtml = ingredientsList
                .slice(0, 4) // Mostrar hasta 4 ingredientes
                .map(i => `<li>${i}</li>`)
                .join('');

            card.innerHTML = `
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">${details.emojiPrincipal}</span>
                        <div class="card-secondary-emojis">${secondaryEmojis}</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">${dishName}</p>
                        <ul class="card-ingredients-list">
                            ${ingredientsListHtml}
                        </ul>
                    </div>
                </div>
            `;
            return card;
        }
        
        function updateCardsPerZone() {
            CARDS_PER_ZONE = mealsPerDayToggle.checked ? 2 : 1;
            TOTAL_CARDS = CARDS_PER_ZONE * DAYS_COUNT;
        }
        
        function loadCreatedDishesFromStorage() {
            const storedDishes = localStorage.getItem(CREATED_DISHES_STORAGE_KEY);
            if (storedDishes) {
                try {
                    createdDishes = JSON.parse(storedDishes);
                } catch (e) {
                    console.error("Error al cargar platos creados:", e);
                    createdDishes = [];
                }
            }
        }

        /**
         * Carga y consolida los estados de disponibilidad (n√∫mero o boolean) de los ingredientes.
         * @returns {Object} Mapa de ingredientes con su disponibilidad (ingName: number|boolean).
         */
        function loadAvailableInventory() {
            const customIngString = localStorage.getItem(CUSTOM_ING_STORAGE_KEY);
            const standardIngString = localStorage.getItem(STANDARD_ING_STORAGE_KEY); 

            let consolidatedInventory = {};

            // 1. Procesar disponibilidad est√°ndar (si existe)
            if (standardIngString) {
                try {
                    const standardConfig = JSON.parse(standardIngString);
                    for (const ingName in standardConfig) {
                        // Usar la disponibilidad si es un n√∫mero
                        const availability = standardConfig[ingName].availability;
                        if (typeof availability === 'number') {
                             consolidatedInventory[ingName] = availability;
                        }
                    }
                } catch(e) { console.error("Error al parsear standardIngredientsConfig:", e); }
            }
            
            // 2. Procesar configuraci√≥n de ingredientes personalizados (para omisiones o override de cantidad)
            if (customIngString) {
                try {
                    const customConfig = JSON.parse(customIngString);
                    for (const key in customConfig) {
                        const item = customConfig[key];
                        const ingName = item.nombre;
                        
                        // Si est√° desactivado, se omite (false)
                        if (item.selected === false) {
                            consolidatedInventory[ingName] = false;
                        } 
                        // Si tiene una cantidad num√©rica, sobrescribe/establece
                        else if (typeof item.availability === 'number') {
                            consolidatedInventory[ingName] = item.availability;
                        }
                        // Si solo est√° seleccionado (true) y no tiene cantidad, se asume disponible (o infinito, por ahora true)
                        else if (item.selected === true) {
                             consolidatedInventory[ingName] = true;
                        }
                    }
                } catch(e) { console.error("Error al parsear customIngredientsConfig:", e); }
            }
            
            // NOTA DE DEBUG: Simular la disponibilidad de tu ejemplo para "Queso Secreto" y "Camarones con Crema" 
            // en caso de que no se carguen del localStorage.
            const standardIngConfigExample = {"Queso Secreto":{"availability":6},"Camarones con Crema":{"availability":4}};
            for (const ingName in standardIngConfigExample) {
                const availability = standardIngConfigExample[ingName].availability;
                if (typeof availability === 'number') {
                    consolidatedInventory[ingName] = availability;
                }
            }

            return consolidatedInventory;
        }

        /**
         * Verifica si un plato creado (objeto) tiene todos sus ingredientes disponibles por cantidad/omisi√≥n.
         */
        function isCreatedDishAvailable(dishObject, inventory) {
            const principals = dishObject.principales || [];
            const carbohidratos = dishObject.carbohidratos || [];
            const verduras = dishObject.verduras || [];

            const allIngredients = [...principals, ...carbohidratos, ...verduras].filter(i => i && i !== 'N/A');

            // 1. Verificar activaci√≥n: TODOS los ingredientes deben estar seleccionados/activos.
            const allIngredientsActivated = allIngredients.every(ing => selectedComponentsSet.has(ing));
            if (!allIngredientsActivated) return false;

            // 2. Verificar disponibilidad (cantidad > 0 o no omitido)
            const allIngredientsAvailable = allIngredients.every(ing => {
                const status = inventory[ing];
                
                if (status === false) return false; // Exclusi√≥n expl√≠cita.
                
                if (typeof status === 'number') {
                    return status > 0; // Exclusi√≥n por cantidad cero/negativa.
                }

                // Si est√° activado (por paso 1) y su status es 'undefined' o 'true', asumimos disponible/infinito.
                return true;
            });

            return allIngredientsAvailable;
        }

        function renderDishHand() {
            dishHandCarousel.innerHTML = '';
            
            // 1. Filtrar platos creados por disponibilidad de ingredientes
            const availableCreatedDishes = createdDishes.filter(dish => 
                isCreatedDishAvailable(dish, customIngredients)
            );
            
            if (availableCreatedDishes.length > 0) {
                availableCreatedDishes.forEach(dish => {
                    const card = createDishCardHtml(dish);
                    dishHandCarousel.appendChild(card);
                });
            } else {
                dishHandCarousel.innerHTML = '<p style="color: #484f58; margin: auto;">No tienes platos creados disponibles con tus ingredientes activos o en suficiente cantidad.</p>';
            }
        }
        
        function renderCards() {
            
            updateCardsPerZone(); 
            const isCreatedMode = useCreatedDishesCheckbox.checked;
            
            // Recargar filtros y inventario
            loadSelectionFilters();
            loadCreatedDishesFromStorage(); 
            
            randomizeButton.style.display = isCreatedMode ? 'none' : 'block';
            dishHandCarousel.style.display = isCreatedMode ? 'flex' : 'none';

            if (isCreatedMode) {
                loadingMessage.textContent = 'Modo Platos Creados activo.';
                renderDishHand();
                
                allZones.forEach(zone => {
                    Array.from(zone.children).forEach(child => {
                        if (child.classList.contains('card') || child.classList.contains('placeholder')) {
                            child.remove();
                        }
                    });
                    
                    for (let i = 0; i < CARDS_PER_ZONE; i++) {
                        const placeholder = document.createElement('div');
                        placeholder.classList.add('placeholder');
                        zone.appendChild(placeholder);
                    }
                });
            } else {
                loadingMessage.textContent = 'Randomizando men√∫...';
                
                allZones.forEach(zone => zone.innerHTML = `<div class="zone-label">${zone.getAttribute('data-day')}</div>`);

                // --- LOGICA DE CONSUMO AQUI ---
                // Crear una copia del inventario para simular el consumo de la semana
                const workingInventory = JSON.parse(JSON.stringify(customIngredients));
                
                const randomDishes = getRandomDishes(TOTAL_CARDS, workingInventory);
                // --- FIN LOGICA DE CONSUMO ---
                
                allZones.forEach((zone, zoneIndex) => {
                    const label = zone.querySelector('.zone-label');
                    zone.innerHTML = '';
                    zone.appendChild(label); 

                    const start = zoneIndex * CARDS_PER_ZONE;
                    const end = start + CARDS_PER_ZONE;
                    
                    randomDishes.slice(start, end).forEach(dishObject => {
                        // dishObject es {name, details}
                        if (dishObject && dishObject.name) { 
                            zone.appendChild(createDishCardHtml(dishObject)); 
                        }
                    });
                    
                    const currentCards = zone.querySelectorAll('.card').length;
                    for (let i = currentCards; i < CARDS_PER_ZONE; i++) {
                        const placeholder = document.createElement('div');
                        placeholder.classList.add('placeholder');
                        zone.appendChild(placeholder);
                    }
                });

                loadingMessage.textContent = 'Men√∫ listo.';
                if (randomDishes.length < TOTAL_CARDS) {
                     loadingMessage.textContent += ` (ADVERTENCIA: Solo se pudieron generar ${randomDishes.length} platos √∫nicos disponibles.)`;
                }
            }
        }

        async function loadMenuData() {
            
            const localMenu = localStorage.getItem(MENU_STORAGE_KEY);
            if (localMenu) {
                try {
                    menuData = JSON.parse(localMenu);
                } catch (e) {
                    menuData = null; 
                }
            }

            if (!menuData) {
                try {
                    const menuResponse = await fetch(DATA_URL);
                    if (!menuResponse.ok) throw new Error(`Error al cargar el men√∫: ${menuResponse.status}`);
                    menuData = await menuResponse.json();
                } catch (error) {
                    loadingMessage.textContent = `Error al cargar los datos del men√∫: ${error.message}`;
                    loadingMessage.style.color = 'red';
                    return; 
                }
            }
            
            try {
                const inventoryResponse = await fetch(INVENTORY_DATA_URL);
                if (!inventoryResponse.ok) throw new Error(`Error al cargar el inventario: ${inventoryResponse.status}`);
                const inventoryData = await inventoryResponse.json();
                
                INGREDIENT_EMOJI_MAP = {};
                inventoryData.inventario.forEach(item => {
                    INGREDIENT_EMOJI_MAP[item.nombre] = item.emoji; 
                });
            } catch (error) {
                console.error("Error al cargar los datos del inventario:", error);
            }
            
            allDishes = menuData.platos_principales.map(d => d.nombre);

            loadSelectionFilters();
            loadCreatedDishesFromStorage(); 
            
            if (useCreatedDishesCheckbox.checked) {
                allZones.forEach(zone => {
                    const label = zone.querySelector('.zone-label');
                    zone.innerHTML = '';
                    zone.appendChild(label);
                });
            }
            
            renderCards(); 
        }
        
        function loadSelectionFilters() {
            // Carga y consolida √≠tems ACTIVADOS (platos e ingredientes)
            const selectionString = localStorage.getItem(SELECTION_STORAGE_KEY);
            if (selectionString) {
                const selections = JSON.parse(selectionString);
                if(Array.isArray(selections)) {
                    selectedComponentsSet = new Set(selections);
                } else {
                    selectedComponentsSet = new Set([
                        ...(Array.isArray(selections.dishes) ? selections.dishes : []), 
                        ...(Array.isArray(selections.ingredients) ? selections.ingredients : [])
                    ]);
                }
            } else {
                selectedComponentsSet = new Set();
            }

            // Cargar inventario consolidado con disponibilidad (N, false, true)
            customIngredients = loadAvailableInventory(); 

            // --- APLICAR FILTRO DE ACTIVACI√ìN/SELECCI√ìN ESTRICTA ---
            if (selectedComponentsSet.size > 0) {
                
                allowedDishes = menuData.platos_principales
                    .filter(dishObject => {
                        // 1. Si el plato mismo est√° activado, se permite.
                        if (selectedComponentsSet.has(dishObject.nombre)) return true; 

                        // 2. Si el plato no est√° activado, verificar si al menos UNO de sus ingredientes est√° activado.
                        const allDishIngredients = [
                            ...(dishObject.principales || []), 
                            ...(dishObject.carbohidratos || []), 
                            ...(dishObject.verduras || [])
                        ].filter(i => i && i !== '-');

                        // Si NINGUNO de sus ingredientes est√° activado, el plato es descartado.
                        return allDishIngredients.some(component => selectedComponentsSet.has(component));
                    })
                    .map(dishObject => dishObject.nombre); 

            } else {
                // Si no hay selecciones, NING√öN plato est√° permitido (Activaci√≥n estricta).
                allowedDishes = [];
            }
            // --- FIN FILTRO DE ACTIVACI√ìN/SELECCI√ìN ---


            // --- APLICAR FILTRO DE DISPONIBILIDAD (Quantity > 0 O NO OMITIDO) ---
            allowedDishes = allowedDishes.filter(dishName => {
                const dish = menuData.platos_principales.find(d => d.nombre === dishName);
                if (!dish) return true;

                const allIngredients = [...(dish.principales || []), ...(dish.carbohidratos || []), ...(dish.verduras || [])]
                    .filter(i => i && i !== '-');

                // El plato es NO PERMITIDO si ALGUNO de sus ingredientes es OMITIDO O TIENE CANTIDAD <= 0.
                const hasUnavailableIngredient = allIngredients.some(ing => {
                    const status = customIngredients[ing];
                    
                    if (status === false) return true; // Exclusi√≥n expl√≠cita.
                    
                    if (typeof status === 'number') {
                        return status <= 0; // Exclusi√≥n por cantidad cero/negativa.
                    }
                    
                    return false;
                });

                return !hasUnavailableIngredient; 
            });
            
            if (allowedDishes.length === 0 && !useCreatedDishesCheckbox.checked) {
                loadingMessage.textContent = 'ADVERTENCIA: No hay platos disponibles con los filtros, omisiones o cantidades de ingredientes seleccionadas.';
                loadingMessage.style.color = 'orange';
            }
        }

        // ===============================================
        // DRAG & DROP EVENT LISTENERS (FLIP Y CASCADA)
        // (Sin cambios, ya que los cambios se enfocaron en la l√≥gica de datos)
        // ===============================================

        document.addEventListener('dragstart', (e) => {
            const card = e.target.closest('.card');
            if (!card || !card.hasAttribute('draggable') || card.getAttribute('draggable') === 'false') return;

            const isFromHand = card.closest('#dish-hand-carousel');

            // Crear placeholder
            placeholder = document.createElement('div');
            placeholder.className = 'placeholder card'; 
            
            const computedStyle = window.getComputedStyle(card);
            placeholder.style.width = computedStyle.width;
            placeholder.style.height = computedStyle.height;
            placeholder.style.paddingBottom = computedStyle.paddingBottom;
            placeholder.style.margin = computedStyle.margin;

            // Configurar imagen de arrastre vac√≠a
            const emptyImg = new Image();
            emptyImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            e.dataTransfer.setDragImage(emptyImg, 0, 0);

            // AHORA AMBOS CASOS SON TRATADOS COMO OPERACI√ìN DE MOVIMIENTO (MOVER)
            draggedCard = card;
            draggedCard.classList.add('dragging');
            
            e.dataTransfer.setData('text/plain', 'card-move'); 
            e.dataTransfer.setData('application/x-dish-source', isFromHand ? 'hand-move' : 'zone');
            e.dataTransfer.effectAllowed = 'move';
            
            // Insertar placeholder y ocultar tarjeta real
            setTimeout(() => {
                if (draggedCard && draggedCard.parentNode) {
                    
                    if (isFromHand) {
                         // Si viene de la mano, la eliminamos inmediatamente del DOM.
                         // Se reinsertar√° al final del drag, ya sea en la zona de drop o en dragend si falla.
                         draggedCard.remove(); 
                    } else {
                         // Si viene de una zona, la reemplazamos con el placeholder.
                         draggedCard.parentNode.insertBefore(placeholder, draggedCard);
                    }
                    draggedCard.style.display = 'none'; 
                }
            }, 0); 
            
            lastRectMap.clear();
        });

        document.querySelectorAll('.drop-zone, #dish-hand-carousel').forEach(zone => {
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('drag-over');

                lastDragEventData.zone = zone;
                lastDragEventData.clientX = e.clientX;
                lastDragEventData.clientY = e.clientY;

                // Mover placeholder inmediatamente para feedback visual.
                if (placeholder && !isUpdating) {
                    if (placeholder.parentNode) placeholder.remove(); 
                    const afterElement = getDragAfterElement(zone, e.clientX);
                    
                    if (afterElement == null) {
                        zone.appendChild(placeholder);
                    } else {
                        zone.insertBefore(placeholder, afterElement);
                    }
                }
                
                // Throttling: Llamar a liveReorderAndFlip solo en el siguiente requestAnimationFrame
                if (draggedCard && !isUpdating) {
                    isUpdating = true;
                    requestAnimationFrame(processDragOverUpdate); 
                }
            });

            zone.addEventListener('dragleave', (e) => {
                if (!zone.contains(e.relatedTarget)) {
                    zone.classList.remove('drag-over');
                }
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                
                if (!placeholder || !draggedCard) {
                    if (draggedCard) clearLiveTransforms();
                    return;
                }
                
                // 1. Capturar posiciones antes de reemplazar el placeholder (para la animaci√≥n final)
                registerLiveTransforms(false);
                
                // L√≥gica UNIFICADA MOVER 
                
                // Si el drop fue en el carrusel (mano), la tarjeta vuelve a la mano.
                if (zone.id === 'dish-hand-carousel') {
                    
                    if (placeholder.parentNode === dishHandCarousel) {
                        placeholder.parentNode.replaceChild(draggedCard, placeholder);
                    }
                    
                    draggedCard.style.display = ''; 
                    draggedCard.classList.remove('dragging');
                    
                } else {
                    // Si el drop fue en una zona de d√≠a: Reemplazar el placeholder con draggedCard.
                    draggedCard.style.display = ''; 
                    draggedCard.classList.remove('dragging');
                    
                    placeholder.parentNode.replaceChild(draggedCard, placeholder);
                }


                // 2. Animar el resto de las tarjetas
                applyFLIPAnimation();

                // Limpieza final
                placeholder = null;
                draggedCard = null; 

                // Re-renderizar placeholders en modo creado
                if (useCreatedDishesCheckbox.checked && zone.classList.contains('drop-zone')) {
                    const currentCards = Array.from(zone.querySelectorAll('.card')).length;
                    Array.from(zone.querySelectorAll('.placeholder')).forEach(p => p.remove());
                    for (let i = currentCards; i < CARDS_PER_ZONE; i++) {
                        const newPlaceholder = document.createElement('div');
                        newPlaceholder.classList.add('placeholder');
                        zone.appendChild(newPlaceholder);
                    }
                }
            });
        });

        document.addEventListener('dragend', (e) => {
            isUpdating = false; 

            if (draggedCard) {
                if (!draggedCard.parentNode) {
                    dishHandCarousel.appendChild(draggedCard);
                } 
                else if (placeholder && placeholder.parentNode) {
                    placeholder.parentNode.replaceChild(draggedCard, placeholder);
                }
                clearLiveTransforms(); 
            }
            
            allZones.forEach(zone => zone.classList.remove('drag-over'));
            dishHandCarousel.classList.remove('drag-over');
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault(); 
        });

        // ===============================================
        // INICIALIZACI√ìN
        // ===============================================

        randomizeButton.addEventListener('click', renderCards);
        consecutiveMealsSelect.addEventListener('change', renderCards); 
        mealsPerDayToggle.addEventListener('change', renderCards); 
        useCreatedDishesCheckbox.addEventListener('change', renderCards);
        
        loadMenuData();
    </script>
</body>
</html>
