<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pantalla 7: Creador de Platos</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKx3G3z3lE7B9f7K54z6W3CFA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        /* ======================================================================= */
        /* VARIABLES Y BASE */
        /* ======================================================================= */
        :root {
            --bg-color: #0d1117;
            --text-color: #c9d1d9;
            --card-bg-color: #2b313a;
            --card-border-color: #484f58;
            --selection-color: #58a6ff;
            --success-color: #238636;
            --failure-color: #a00000;
            --coin-color: #ffc700; /* NUEVA ADICI√ìN: MONEDAS */ 
            --button-bg-color: #21262d;
            --button-hover-color: #30363d;
            --button-border-color: #30363d;
            --button-text-color: #c9d1d9;
            --action-button-color: #2ea44f; 

            /* --- Card Sizing --- */
            --carousel-height: 20vh;
            --lift-amount: 4.5vh;
            --ing-card-carousel-padding: 0.5vh;
            --ing-card-aspect-ratio: calc(49 / 70);
            --ing-card-base-height: calc(var(--carousel-height) - (var(--ing-card-carousel-padding) * 2)); 
            --overlap-margin: calc(-1 * var(--ing-card-base-height) * var(--ing-card-aspect-ratio) * 0.40);

            /* Dish Card Sizing (referencia visual) */
            --dish-card-width: 120px;
            --dish-card-aspect-ratio: calc(70 / 49); 
            --dish-card-calculated-height: calc(var(--dish-card-width) * var(--dish-card-aspect-ratio));
            
            --animation-duration: 0.5s;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        /* ----------------------------------------------------------------------- */
        /* TOP BAR & HEADERS */
        /* ----------------------------------------------------------------------- */
        #top-bar { 
            height: 15vh; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 0 10px; 
            flex-shrink: 0; 
        }
        #game-info-area { 
            display: flex; 
            align-items: center; 
            gap: 0px; 
        }
        h2 { 
            font-size: 0.3em; 
            margin: 0; 
            color: var(--selection-color); 
            flex-grow: 1; 
            text-align: left; 
        }

        /* ----------------------------------------------------------------------- */
        /* MAZOS (DECK STACK) 3D */
        /* ----------------------------------------------------------------------- */
        .card-stack { 
            width: 70px; 
            height: 7vh; 
            border-radius: 6px; 
            position: relative; 
            background-color: #161b22; 
            border: 2px solid #30363d; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4); 
            cursor: pointer; 
            flex-shrink: 0; 
            display: block; 
            transition: transform 0.2s; 
            margin-right: 15px;
            perspective: 100px; 
            overflow: visible; 
            
            /* RESTORED: Texto de mazo centrado y claro */
            font-size: 0.7em; 
            text-align: center; 
            display: flex; /* Asegura que el inner est√© centrado si no usamos absolute */
            align-items: center;
            justify-content: center;
        }
        .card-stack:hover { 
             transform: translateY(-2px); 
        }

        .card-stack-inner {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
            background-color: #161b22;
            transition: transform 0.2s;
        }
        
        .card-stack-depth {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transform-origin: bottom center;
            pointer-events: none;
            z-index: 9;
        }

        .card-stack-depth-card {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #30363d;
            border: 1px solid #484f58;
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .card-stack-inner:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--card-bg-color); 
            border: 2px solid var(--card-border-color);
            border-radius: 6px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            z-index: -1; 
            transform: translateZ(5px); 
            transition: transform 0.2s;
        }

        .card-stack:hover .card-stack-inner:before {
            transform: translateZ(10px) translateY(-2px);
        }

        .stack-icon { font-size: 0.7em; }
        .stack-count { font-size: 1.2em; font-weight: bold; line-height: 1; }
        
        /* NUEVA ADICI√ìN: ESTILO DE MONEDAS */
        #coin-stack .card-stack-inner .stack-icon {
            color: var(--coin-color);
        }

        /* ----------------------------------------------------------------------- */
        /* BOARD & MESSAGE DISPLAY */
        /* ----------------------------------------------------------------------- */
        #message-display { 
            height: 15vh; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-family: 'Press Start 2P', cursive; 
            font-size: 0.7em; 
            position: relative; 
        }
        #display-text-placeholder { 
            position: absolute; 
            color: #484f58; 
        }
        #display-text { 
            position: absolute; 
            opacity: 0; 
            transition: opacity 0.3s; 
        }
        #display-text.success { color: var(--success-color); }
        #display-text.failure { color: var(--failure-color); }
        #display-text.default { color: var(--selection-color); }

        #dish-board { 
            height: 20vh; 
            margin: 5px 10px; 
            border: 2px dashed #30363d; 
            border-radius: 8px; 
            background-color: #161b22; 
            padding: 10px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            gap: 15px; 
            flex-shrink: 0; 
            flex-wrap: wrap; 
            position: relative; 
        }
        #board-placeholder { 
            font-size: 1.1em; 
            color: #484f58; 
            transition: opacity 0.3s; 
        }

        /* ----------------------------------------------------------------------- */
        /* STATS */
        /* ----------------------------------------------------------------------- */
        #stats-container { 
            display: flex; 
            justify-content: space-around; 
            padding: 10px; 
            flex-shrink: 0; 
        }
        .stat-item { 
            text-align: center; 
        }
        .stat-label { 
            font-size: 0.8em; 
            color: #b0b8c5; 
        }
        .stat-value { 
            font-size: 1.5em; 
            font-weight: bold; 
            color: var(--text-color); 
        }
        .stat-value.danger { 
            color: var(--failure-color); 
        }
        
        /* ----------------------------------------------------------------------- */
        /* BOTONES RESTAURADOS */
        /* ----------------------------------------------------------------------- */
        button {
            background-color: var(--button-bg-color);
            color: var(--button-text-color);
            border: 1px solid var(--button-border-color);
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-weight: 600;
        }

        button:hover {
            background-color: var(--button-hover-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #action-buttons { 
            padding: 10px; 
            flex-shrink: 0; 
        }
        
        /* Colores de botones de acci√≥n restaurados */
        #action-buttons button {
            background-color: var(--action-button-color);
            border-color: #388f4c;
            color: white;
            margin: 0 5px;
        }
        
        #action-buttons button:hover:not(:disabled) {
            background-color: #2c8c46;
        }
        
        #discard-cards-button {
            background-color: #9f3636;
            border-color: #880000;
        }
        #discard-cards-button:hover:not(:disabled) {
            background-color: #880000;
        }
        
        /* ----------------------------------------------------------------------- */
        /* CARRUSEL Y CARTA DE INGREDIENTE RESTAURADA */
        /* ----------------------------------------------------------------------- */
        #card-carousel {
            height: var(--carousel-height);
            display: flex;
            gap: 0px;
            overflow-x: auto;
            padding: var(--ing-card-carousel-padding) 10px; 
            border-radius: 8px;
            background-color: #161b22;
            align-items: flex-end;
            flex-shrink: 0;
            position: relative;
            justify-content: flex-start;
            margin: 5px 10px 10px 10px;
        }

        .ingredient-card {
            height: 60%; 
            width: auto; 
            aspect-ratio: var(--ing-card-aspect-ratio);
            flex: 0 0 auto;
            
            background-color: var(--card-bg-color);
            border: 2px solid var(--card-border-color);
            border-radius: 10px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            margin-top: var(--lift-amount);
            
            display: flex;
            flex-direction: column;
            justify-content: space-between; 
            align-items: center;
            padding: 1px;
            
            margin-right: var(--overlap-margin);
            transform-origin: bottom center;
            transition: 
                transform var(--animation-duration) ease-out, 
                box-shadow 0.2s ease-out, 
                border-color 0.2s, 
                opacity 0.2s, 
                margin-top 0.2s, 
                margin-right 0.2s;
            cursor: pointer;
            z-index: 10;
        }
        
        .ingredient-card:hover {
            transform: translateY(calc(-1 * var(--lift-amount) / 2));
        }

        .ingredient-card.selected { 
            transform: translateY(calc(-1 * var(--lift-amount))) translateX(0px); 
            border-color: var(--selection-color); 
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.6), 0 0 10px var(--selection-color); 
        }

        .card-emoji {
            font-size: 3em;
            flex-grow: 1; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .card-name {
            font-size: 0.6em;
            text-align: center;
            margin-top: auto;
            color: var(--text-color);
        }

        .card-corner {
            position: absolute;
            font-size: 0.8em;
            font-weight: bold;
            color: var(--selection-color);
        }

        .corner-top-left { top: 5px; left: 5px; }
        .corner-bottom-right { bottom: 5px; right: 5px; transform: rotate(180deg); }

        /* ----------------------------------------------------------------------- */
        /* POP-UPS RESTAURADOS */
        /* ----------------------------------------------------------------------- */
        .popup {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            display: none; 
            animation: fadeIn 0.3s;
        }
        
        .popup-content {
            background-color: var(--card-bg-color);
            margin: 10% auto;
            padding: 20px;
            border: 1px solid var(--card-border-color);
            width: 80%;
            max-width: 600px;
            border-radius: 12px;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s;
        }
        
        /* Estilos para el listado de platos creados (dentro del popup) */
        .collected-dishes {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            padding: 10px 0;
            max-height: 40vh; 
            overflow-y: auto;
        }
        
        /* Estilos para el recetario (dentro del popup) */
        #available-recipes-container {
            max-height: 40vh; 
            overflow-y: auto;
            padding: 10px;
            text-align: left;
        }
        .recipe-item {
            padding: 10px;
            border-bottom: 1px dashed #30363d;
            margin-bottom: 10px;
        }
        .recipe-item h4 {
            color: var(--selection-color);
            margin: 0 0 5px 0;
        }
        .recipe-ingredients {
            font-size: 0.9em;
            color: #b0b8c5;
        }

        /* ----------------------------------------------------------------------- */
        /* ESTILOS DE ANIMACI√ìN DE CARTAS DE PLATO (result-dish-card) */
        /* ----------------------------------------------------------------------- */
        
        /* Se eliminaron los keyframes y clases de animaci√≥n de robo de cartas */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .ingredient-card.played {
            position: absolute !important; 
            margin: 0 !important; 
            opacity: 1;
            transform: none; 
            transition: transform var(--animation-duration) ease-in-out, opacity var(--animation-duration) ease-in-out;
            z-index: 15;
            cursor: default;
        }
        /* Clase para las cartas que est√°n en movimiento (Recycle o Discard) */
        .moving-card { 
            position: fixed !important; 
            margin: 0 !important; 
            transform: none; 
            transition: none;
        }


        .result-dish-card { 
            width: var(--dish-card-width); 
            height: var(--dish-card-calculated-height); 
            border: 2px solid var(--success-color); 
            border-radius: 8px; 
            position: absolute; 
            z-index: 100; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%) scale(0.5); 
            padding: 5px; 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
            background-color: #1f242b;
            opacity: 0;
            transition: 
                transform var(--animation-duration) ease-out, 
                opacity var(--animation-duration) ease-out;
        }
        
        .result-dish-card.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1); 
        }
        
        .result-dish-card.hide {
            opacity: 0;
            transform: translate(-50%, -50%) scale(1.5); 
        }

        .card-inner-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            text-align: left;
            overflow: hidden;
            font-size: 0.9em;
        }
        .card-image-zone {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px 0;
            position: relative;
        }
        .card-main-emoji {
            font-size: 2em;
        }
        .card-secondary-emojis {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 0.8em;
            line-height: 1;
        }
        .card-dish-name {
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 5px;
            margin-bottom: 5px;
            color: white;
            text-align: center;
        }
        .card-ingredients-list {
            list-style: none;
            padding-left: 0;
            margin: 0;
            font-size: 0.75em;
        }
        .card-ingredients-list li {
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            line-height: 1.2;
            color: #b0b8c5;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <h2>Mini-Juego: Creador de Platos üë®‚Äçüç≥</h2>

        <div id="game-info-area">
            
            <div id="coin-stack" class="card-stack" title="Monedas o Puntaje Acumulado">
                <div class="card-stack-inner">
                    <i class="fas fa-coins stack-icon" style="color: var(--coin-color);"></i>
                    <span id="coin-count" class="stack-count">0</span>
                    Monedas
                </div>
            </div>
            <div id="deck-stack" class="card-stack" title="Cartas restantes en el mazo principal">
                <div class="card-stack-inner">
                    <i class="fas fa-layer-group stack-icon"></i>
                    <span id="deck-count" class="stack-count">0</span>
                    Mazo
                </div>
            </div>

            <div id="created-dishes-stack" class="card-stack" title="Platos creados exitosamente">
                <div class="card-stack-inner">
                    <i class="fas fa-trophy stack-icon"></i>
                    <span id="dishes-created-count" class="stack-count">0</span>
                    Platos
                </div>
            </div>

            <button id="show-recipes-button">üìú Recetas</button>
        </div>
    </div>

    <div id="message-display">
        <span id="display-text-placeholder">ESPERANDO ACCI√ìN..</span>
        <span id="display-text" class="default"></span>
    </div>

    <div id="dish-board">
        <span id="board-placeholder">Selecciona hasta 3 ingredientes y **JUEGA** para colocarlos aqu√≠.</span>
    </div>

    <div id="stats-container">
        <div class="stat-item">
            <span class="stat-label">Platos Creados</span>
            <span id="score-value" class="stat-value success">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Manos Restantes (Jugar)</span>
            <span id="plays-remaining-value" class="stat-value">14</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Descartes Restantes</span>
            <span id="discards-remaining-value" class="stat-value">14</span>
        </div>
    </div>

    <div id="action-buttons">
        <button id="play-cards-button" disabled>Jugar Tarjetas (0)</button>
        <button id="discard-cards-button" disabled>Descartar Tarjetas</button>
        <button id="go-to-pantalla2-button">Volver a Inventario</button>
        <button id="reset-game-button" style="background-color: #880000; color: white; border-color: #9f3636;">Reiniciar Juego</button>
        <button id="shuffle-cards-button" style="display: none;">Rebarajar</button>
    </div>

    <div id="card-carousel">
    </div>

    <div id="dish-popup" class="popup">
        <div class="popup-content">
            <span class="close-button" style="position: absolute; top: 10px; right: 20px; font-size: 2em; color: var(--text-color); cursor: pointer;">&times;</span>
            <h3>Platos Creados Exitosamente</h3>
            <div id="collected-dishes-container" class="collected-dishes">
                <p id="no-dishes-message">A√∫n no has creado ning√∫n plato exitosamente.</p>
            </div>
        </div>
    </div>

    <div id="recipe-popup" class="popup">
        <div class="popup-content">
            <span class="close-button" id="close-recipes-popup" style="position: absolute; top: 10px; right: 20px; font-size: 2em; color: var(--text-color); cursor: pointer;">&times;</span>
            <h3>Recetario de Platos Disponibles üìú</h3>
            <div id="available-recipes-container">
                <p>Cargando recetas...</p>
            </div>
        </div>
    </div>


    <script>
        // ===============================================
        // DATOS BASE Y CONFIGURACI√ìN
        // ===============================================

        const BASE_DATA_URL = 'https://djless.github.io/magordito_menu_semanal/calendario_menus_2025/data/';
        const MENU_DB_PATH = BASE_DATA_URL + 'menu_db.json';
        const INVENTORY_DATA_URL = BASE_DATA_URL + 'inventario_db.json';
        const ANIMATION_DURATION = 500; 
        
        // MODIFICACI√ìN: Clave para el almacenamiento de platos desbloqueados
        const UNLOCKED_DISHES_KEY = 'unlockedDishes'; 

        const DISH_EMOJI_MAP = {
            "Pasta Cl√°sica con Salsa (a elecci√≥n)": "üçù", "Bowl de Arroz, Prote√≠na y Vegetales": "üçö",
            "Prote√≠na con Papa y Ensalada/Guiso": "ü•î", "Garbanzos y Prote√≠na con Acompa√±amiento": "ü´ò",
            "Porotos Negros con Prote√≠na y Vegetales": "ü•´", "Hamburguesa Completa (Carne o Vegana)": "üçî",
            "S√°ndwich de Prote√≠na (Carne o Vegana)": "ü•™", "Plato de Sopa (con Legumbres o Prote√≠na)": "ü•£",
            "Salteado Vegano Completo": "üçú", "Pizza Casera con Ensalada": "üçï",
            "Tallarines en Salsa Alfredo con Prote√≠na": "üçù", "Charquic√°n Chileno Tradicional": "üç≤",
            "Empanada (Pino o Queso) con Ensalada": "ü•ü", "Hummus con Verduras y Pan Pita": "ü•ô",
            "Ensalada Completa": "ü•ó",
        };

        let ALL_DISH_RECIPES = [];
        
        // MODIFICACI√ìN: Funci√≥n para obtener los platos desbloqueados desde localStorage
        function getUnlockedDishes() {
            try {
                const unlockedDishes = localStorage.getItem(UNLOCKED_DISHES_KEY);
                return unlockedDishes ? JSON.parse(unlockedDishes) : [];
            } catch (e) {
                console.error("Error al leer unlockedDishes de localStorage:", e);
                return [];
            }
        }

        function setupDishRecipes(menuDb) {
            if (!menuDb || !menuDb.platos_principales) {
                console.error("Base de datos de men√∫s no v√°lida o incompleta.");
                showMessage("ERROR: La base de datos de platos est√° vac√≠a o es incorrecta.", 'failure');
                return;
            }
            
            // 1. Cargar recetas base del archivo est√°tico
            let baseRecipes = menuDb.platos_principales.map(dish => ({
                name: dish.nombre,
                emoji: DISH_EMOJI_MAP[dish.nombre] || "",
                carbohidratos: dish.carbohidratos || [],
                principales: dish.principales || [],
                verduras: dish.verduras || [],
                points: dish.puntaje || 1
            }));
            
            // 2. Cargar platos desbloqueados
            const unlockedDishes = getUnlockedDishes();
            
            // 3. Combinar (asegurando no duplicados)
            const allRecipesMap = new Map();
            
            // Agregar recetas base
            baseRecipes.forEach(recipe => allRecipesMap.set(recipe.name, recipe));
            
            // Agregar recetas desbloqueadas (si un plato base existe, se sobrescribe con el desbloqueado si es necesario, 
            // pero lo importante es que los nuevos est√©n presentes)
            unlockedDishes.forEach(unlockedDish => {
                // El formato de unlockedDishes desde main.js/desbloquearRecompensa deber√≠a ser compatible o similar
                const recipeData = {
                    name: unlockedDish.nombre,
                    emoji: DISH_EMOJI_MAP[unlockedDish.nombre] || unlockedDish.emoji || "",
                    carbohidratos: unlockedDish.carbohidratos || [],
                    principales: unlockedDish.principales || [],
                    verduras: unlockedDish.verduras || [],
                    points: unlockedDish.puntaje || 1 
                };
                allRecipesMap.set(unlockedDish.nombre, recipeData);
            });
            
            ALL_DISH_RECIPES = Array.from(allRecipesMap.values());
        }

        const SELECTION_STORAGE_KEY = 'selectedDishesAndIngredients';
        const CUSTOM_ING_STORAGE_KEY = 'customIngredientsConfig';
        const STANDARD_ING_STORAGE_KEY = 'standardIngredientsConfig';

        let ALL_INGREDIENTS = [];
        let INGREDIENT_EMOJI_MAP = {};
        let AVAILABLE_INGREDIENT_POOL = [];
        let ALL_INGREDIENT_OBJECTS = new Map();

        async function loadFilteredIngredients() {
            let selectedItems = new Set();
            let customIngredients = {};
            let standardIngredientsConfig = {};
            let hasSelectionData = false; // <<< MODIFICACI√ìN: Nuevo indicador de datos de selecci√≥n encontrados

            let inventory;
            try {
                const response = await fetch(INVENTORY_DATA_URL);
                if (!response.ok) throw new Error(`HTTP status: ${response.status}`);
                inventory = await response.json();
            } catch (e) {
                console.error("Error al cargar inventario_db.json. La librer√≠a 'inventario_db' fall√≥.", e);
                showMessage("ERROR: Fallo al cargar la librer√≠a de Inventario.", 'failure');
                inventory = { inventario: [] };
            }

            try {
                const storedSelection = localStorage.getItem(SELECTION_STORAGE_KEY);
                const storedCustom = localStorage.getItem(CUSTOM_ING_STORAGE_KEY);
                
                if (storedSelection) {
                    selectedItems = new Set(JSON.parse(storedSelection).filter(item => !item.startsWith('Plato')));
                    hasSelectionData = true; // Se encontr√≥ data de selecci√≥n
                }
                if (storedCustom) {
                    customIngredients = JSON.parse(storedCustom);
                    hasSelectionData = true; // Se encontr√≥ data de ingredientes custom
                }
                
                const storedStandard = localStorage.getItem(STANDARD_ING_STORAGE_KEY);
                if (storedStandard) standardIngredientsConfig = JSON.parse(storedStandard);

            } catch(e) {
                console.warn("No se pudo cargar la configuraci√≥n de localStorage. Usando inventario base sin filtrar.", e);
                // Si falla la carga, hasSelectionData podr√≠a ser false, lo cual es correcto.
            }

            const finalIngredients = [];
            const emojiMap = {};
            ALL_INGREDIENT_OBJECTS.clear();

            // L√≥gica de fallback basada en si se encontr√≥ data de selecci√≥n.
            // Si hay data de selecci√≥n (incluso si est√° vac√≠a), NO se carga el inventario completo.
            const useFullBaseFallback = !hasSelectionData; 

            inventory.inventario
                .filter(ing => ing.activo)
                .forEach(ing => {
                    const ingName = ing.nombre;
                    const isSelected = selectedItems.has(ingName);

                    if (useFullBaseFallback || isSelected) {
                        const config = standardIngredientsConfig[ingName] || {};
                        const ingredientData = {
                            id: ingName,
                            name: ingName,
                            type: ing.categoria.charAt(0).toUpperCase() + ing.categoria.slice(1),
                            emoji: ing.emoji,
                            availability: Math.max(1, config.availability || ing.cantidad_disponible || 1),
                            isCustom: false,
                            baseName: ingName
                        };
                        finalIngredients.push(ingredientData);
                        emojiMap[ingName] = ing.emoji;
                        ALL_INGREDIENT_OBJECTS.set(ingName, ingredientData);
                    }
                });

            // CORRECCI√ìN CLAVE: Asegurar ID √∫nica para Ingredientes Personalizados
            Object.values(customIngredients).forEach(customIng => {
                if (customIng.nombre && customIng.selected) {
                    const ingName = customIng.nombre;
                    const uniqueId = ingName + '_CUSTOM'; // <<< MODIFICACI√ìN: ID √∫nica para evitar conflictos
                    const typeLabel = customIng.categoria.charAt(0).toUpperCase() + customIng.categoria.slice(1);
                    const ingredientData = {
                        id: uniqueId, // Usar el ID √∫nico aqu√≠
                        name: customIng.nombre + ' (P)', 
                        baseName: customIng.nombre,
                        type: typeLabel,
                        emoji: "‚ú®",
                        availability: Math.max(1, customIng.availability || 1),
                        isCustom: true
                    };
                    finalIngredients.push(ingredientData);
                    emojiMap[uniqueId] = ingredientData.emoji;
                    ALL_INGREDIENT_OBJECTS.set(uniqueId, ingredientData); // Usar el ID √∫nico en el mapa
                }
            });

            ALL_INGREDIENTS = finalIngredients;
            INGREDIENT_EMOJI_MAP = emojiMap;

            AVAILABLE_INGREDIENT_POOL = [];
            ALL_INGREDIENT_OBJECTS.forEach(ing => {
                const count = ing.availability;
                for (let i = 0; i < count; i++) {
                    AVAILABLE_INGREDIENT_POOL.push(ing.id);
                }
            });

            AVAILABLE_INGREDIENT_POOL = AVAILABLE_INGREDIENT_POOL.sort(() => Math.random() - 0.5);


            if (AVAILABLE_INGREDIENT_POOL.length === 0) {
                showMessage("No hay ingredientes disponibles en el inventario para jugar.", 'failure');
            }

            return true;
        }

        // ===============================================
        // L√ìGICA DE JUEGO Y UTILIDADES
        // ===============================================

        function checkRecipeMatch(ingredients) {
            if (ingredients.length === 0) return null;

            for (const recipe of ALL_DISH_RECIPES) {
                const recipeRequiresCarbo = recipe.carbohidratos.length > 0 && !recipe.carbohidratos.includes('-');
                const recipeRequiresPrincipal = recipe.principales.length > 0 && !recipe.principales.includes('-');
                const recipeRequiresVerdura = recipe.verduras.length > 0 && !recipe.verduras.includes('-');

                const carboReqMet = !recipeRequiresCarbo || ingredients.some(ing =>
                    ing.type === 'Carbohidrato' && recipe.carbohidratos.some(reqIng => (ing.baseName || ing.id).includes(reqIng))
                );
                const principalReqMet = !recipeRequiresPrincipal || ingredients.some(ing =>
                    ing.type === 'Principal' && recipe.principales.some(reqIng => (ing.baseName || ing.id).includes(reqIng))
                );
                const verduraReqMet = !recipeRequiresVerdura || ingredients.some(ing =>
                    ing.type === 'Verdura' && recipe.verduras.some(reqIng => (ing.baseName || ing.id).includes(reqIng))
                );

                if (carboReqMet && principalReqMet && verduraReqMet) {
                    return { ...recipe, requiredCount: ingredients.length };
                }
            }
            return null;
        }

        const MAX_SELECTION = 3;
        const CAROUSEL_SIZE = 8;
        const INITIAL_PLAYS = 14;
        const INITIAL_DISCARDS = 14;

        // --- ELEMENTOS DOM ---
        const carousel = document.getElementById('card-carousel');
        const dishBoard = document.getElementById('dish-board');
        const playButton = document.getElementById('play-cards-button');
        const discardButton = document.getElementById('discard-cards-button');
        const resetGameButton = document.getElementById('reset-game-button');
        const shuffleButton = document.getElementById('shuffle-cards-button');
        const boardPlaceholder = document.getElementById('board-placeholder');
        const scoreValueElement = document.getElementById('score-value');
        const playsRemainingElement = document.getElementById('plays-remaining-value');
        const discardsRemainingElement = document.getElementById('discards-remaining-value');
        // const showDishesButton = document.getElementById('show-dishes-button'); // ELIMINADO
        const goToPantalla2Button = document.getElementById('go-to-pantalla2-button'); // NUEVO
        const createdDishesStack = document.getElementById('created-dishes-stack'); // NUEVO
        const dishPopup = document.getElementById('dish-popup');
        const closeButton = dishPopup.querySelector('.close-button');
        const collectedDishesContainer = document.getElementById('collected-dishes-container');
        const noDishesMessage = document.getElementById('no-dishes-message');
        const recipePopup = document.getElementById('recipe-popup');
        const closeRecipesButton = document.getElementById('close-recipes-popup');
        const showRecipesButton = document.getElementById('show-recipes-button');
        const availableRecipesContainer = document.getElementById('available-recipes-container');
        const messageDisplay = document.getElementById('message-display');
        const displayPlaceholder = document.getElementById('display-text-placeholder');
        const deckCountElement = document.getElementById('deck-count');
        const createdDishesCountElement = document.getElementById('dishes-created-count');
        const coinCountElement = document.getElementById('coin-count'); // NUEVA ADICI√ìN: MONEDAS

        // --- ESTADO DEL JUEGO ---
        let selectedCards = [];
        let isProcessingPlay = false;
        let score = loadGameData('score', 0);
        let coins = loadGameData('coins', 0); // NUEVA ADICI√ìN: MONEDAS
        let playsRemaining = loadGameData('playsRemaining', INITIAL_PLAYS);
        let discardsRemaining = loadGameData('discardsRemaining', INITIAL_DISCARDS);
        let successfullyCreatedDishes = loadGameData('successfullyCreatedDishes', []);
        let usedIngredientIds = loadGameData('usedIngredientIds', []);

        function saveGameData(key, data) { localStorage.setItem(`dishCreator_${key}`, JSON.stringify(data)); }
        function loadGameData(key, defaultValue) {
            const data = localStorage.getItem(`dishCreator_${key}`);
            if (data) { try { return JSON.parse(data); } catch (e) { return defaultValue; } }
            return defaultValue;
        }
        
        // Funci√≥n: Renderiza las capas para el efecto 3D
        function renderCardStackDepth(elementId, count) {
            const stack = document.getElementById(elementId);
            let depthContainer = stack.querySelector('.card-stack-depth');
            
            const MAX_CARDS_VISIBLE = 40;
            const CARDS_PER_LAYER = 1; 
            const cardsToRender = Math.min(Math.floor(count / CARDS_PER_LAYER), MAX_CARDS_VISIBLE); 

            if (!depthContainer) {
                depthContainer = document.createElement('div');
                depthContainer.className = 'card-stack-depth';
                stack.insertBefore(depthContainer, stack.querySelector('.card-stack-inner'));
            }

            depthContainer.innerHTML = '';
            for (let i = 0; i < cardsToRender; i++) {
                const cardDepth = document.createElement('div');
                cardDepth.className = 'card-stack-depth-card';
                const translateY = (i + 1) * -1; 
                const translateZ = (i + 1) * -3; 
                cardDepth.style.transform = `translate3d(0, ${translateY}px, ${translateZ}px)`;
                depthContainer.appendChild(cardDepth);
            }
        }

        function updateStats() {
            scoreValueElement.textContent = score;
            playsRemainingElement.textContent = playsRemaining;
            discardsRemainingElement.textContent = discardsRemaining;
            
            // MODIFICACI√ìN: Actualizar el texto del bot√≥n que ahora va a pantalla2 (opcional, pero √∫til)
            // goToPantalla2Button.textContent = `Volver a Inventario (${successfullyCreatedDishes.length})`;
            
            if (deckCountElement) deckCountElement.textContent = AVAILABLE_INGREDIENT_POOL.length;
            if (createdDishesCountElement) createdDishesCountElement.textContent = successfullyCreatedDishes.length;
            if (coinCountElement) coinCountElement.textContent = coins; // NUEVA ADICI√ìN: MONEDAS

            renderCardStackDepth('deck-stack', AVAILABLE_INGREDIENT_POOL.length);
            renderCardStackDepth('created-dishes-stack', successfullyCreatedDishes.length);

            saveGameData('score', score);
            saveGameData('coins', coins); // NUEVA ADICI√ìN: MONEDAS
            saveGameData('playsRemaining', playsRemaining);
            saveGameData('discardsRemaining', discardsRemaining);
            saveGameData('usedIngredientIds', usedIngredientIds);
            saveGameData('successfullyCreatedDishes', successfullyCreatedDishes); // Asegurar que se guarda el historial

            playsRemainingElement.classList.toggle('danger', playsRemaining <= 0);
            discardsRemainingElement.classList.toggle('danger', discardsRemaining <= 0);
            updateShuffleButtonVisibility();
        }

        function updateShuffleButtonVisibility() {
            const cardsInCarousel = carousel.children.length;
            if (cardsInCarousel === 0 && AVAILABLE_INGREDIENT_POOL.length === 0) {
                shuffleButton.style.display = 'inline-block';
                playButton.disabled = true;
                discardButton.disabled = true;
                shuffleButton.disabled = usedIngredientIds.length === 0;

                if (usedIngredientIds.length === 0) {
                    shuffleButton.textContent = 'Mazo Vac√≠o (0)';
                } else {
                    shuffleButton.textContent = `Rebarajar (${usedIngredientIds.length} cartas)`;
                }
            } else {
                shuffleButton.style.display = 'none';
            }
        }

        function createCardElement(ingredientId) {
            const ingData = ALL_INGREDIENT_OBJECTS.get(ingredientId);
            if (!ingData) { return null; }

            // MODIFICACI√ìN: Se elimina la clase 'new-card'
            const card = document.createElement('div');
            card.className = 'ingredient-card';
            card.setAttribute('data-id', ingData.id);
            card.setAttribute('data-name', ingData.name);
            card.setAttribute('data-type', ingData.type);
            card.setAttribute('data-basename', ingData.baseName);

            card.innerHTML = `
                <div style="height: 100%; display: flex; flex-direction: column; justify-content: space-between; align-items: center; width: 100%; position: relative;">
                    <span class="card-corner corner-top-left">${ingData.type.charAt(0)}</span>
                    <span class="card-emoji">${ingData.emoji}</span>
                    <span class="card-name">${ingData.name.replace(' (P)', '')}</span>
                    <span class="card-corner corner-bottom-right">${ingData.type.charAt(0)}</span>
                </div>
            `;

            card.addEventListener('click', () => toggleCardSelection(card));
            return card;
        }

        function toggleCardSelection(card) {
            if (isProcessingPlay) return;
            const cardId = card.getAttribute('data-id');
            const isSelected = card.classList.contains('selected');

            if (isSelected) {
                card.classList.remove('selected');
                selectedCards = selectedCards.filter(id => id !== cardId);
            } else {
                if (selectedCards.length < MAX_SELECTION) {
                    card.classList.add('selected');
                    selectedCards.push(cardId);
                } else {
                    showMessage("Solo puedes seleccionar un m√°ximo de 3 tarjetas.", 'failure');
                }
            }
            updateActionButtons();
        }

        function drawRandomCardId() {
            return AVAILABLE_INGREDIENT_POOL.length === 0 ? null : AVAILABLE_INGREDIENT_POOL.pop();
        }

        // NUEVAS FUNCIONES DE ANIMACI√ìN Y ROBO (Reemplazo de la funci√≥n original fillCarousel)

        function animateDrawToCarousel(ingredientId, index) {
            const ingData = ALL_INGREDIENT_OBJECTS.get(ingredientId);
            if (!ingData) return 0;

            const tempCard = createCardElement(ingredientId);
            
            // 1. Preparar tarjeta temporal (posici√≥n fija para animaci√≥n)
            tempCard.style.position = 'fixed';
            tempCard.style.margin = '0';
            tempCard.style.zIndex = 40 + index; 
            tempCard.style.opacity = '0';
            tempCard.style.transition = 'none';

            // Calcular dimensiones de la tarjeta movible (12vh es 60% del alto del carrusel)
            const cardHeight = '12vh'; 
            const aspectRatio = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ing-card-aspect-ratio')) || (49 / 70);
            
            tempCard.style.height = cardHeight;
            tempCard.style.width = `calc(${cardHeight} * ${aspectRatio})`;

            document.body.appendChild(tempCard);

            const deckStack = document.getElementById('deck-stack');
            const deckRect = deckStack.getBoundingClientRect();
            
            // Posici√≥n Inicial: Centro de la Pila del Mazo
            const tempCardRect = tempCard.getBoundingClientRect();
            const startX = deckRect.left + deckRect.width / 2 - tempCardRect.width / 2;
            const startY = deckRect.top + deckRect.height / 2 - tempCardRect.height / 2;
            
            tempCard.style.top = `${startY}px`;
            tempCard.style.left = `${startX}px`;

            // 2. Calcular Posici√≥n Objetivo (Usando un elemento dummy para forzar el espacio en el carrusel)
            const dummyCard = createCardElement(ingredientId);
            dummyCard.style.visibility = 'hidden';
            dummyCard.style.position = 'relative'; // Asegura que tome espacio
            carousel.appendChild(dummyCard);

            // Forzar reflow y obtener posici√≥n objetivo
            const targetRect = dummyCard.getBoundingClientRect();
            
            const endX = targetRect.left;
            const endY = targetRect.top;

            // 3. Secuencia de Animaci√≥n
            const totalDelay = index * 100;
            
            // Fase 1: Aparecer y levantarse de la pila
            setTimeout(() => {
                tempCard.style.transition = `opacity 100ms ease-out, transform 200ms ease-out`;
                tempCard.style.opacity = '1';
                // Levantar y mover ligeramente hacia la direcci√≥n del carrusel
                tempCard.style.transform = `translateY(-${deckRect.height}px) scale(0.9)`; 
            }, totalDelay); 

            // Fase 2: Mover al slot final del carrusel
            setTimeout(() => {
                tempCard.style.transition = `transform ${ANIMATION_DURATION}ms ease-in-out, opacity ${ANIMATION_DURATION}ms linear`;
                // Transformar desde la posici√≥n fija de inicio a la posici√≥n fija de destino
                tempCard.style.transform = `translate(${endX - startX}px, ${endY - startY}px) rotate(0deg) scale(1)`;

                // Fase 3: Limpieza e inserci√≥n final
                setTimeout(() => {
                    // Eliminar el clon m√≥vil
                    tempCard.remove(); 
                    
                    // Eliminar el dummy e insertar la tarjeta final
                    carousel.removeChild(dummyCard); 
                    const finalCardElement = createCardElement(ingredientId);
                    carousel.appendChild(finalCardElement);

                }, ANIMATION_DURATION);

            }, totalDelay + 250); 
            
            return ANIMATION_DURATION + totalDelay + 300; 
        }

        function fillCarousel() {
            const cardsNeeded = CAROUSEL_SIZE - carousel.children.length;
            const newCardIds = [];
            for (let i = 0; i < cardsNeeded; i++) {
                const newId = drawRandomCardId();
                if (newId) newCardIds.push(newId); else break;
            }
            
            if (newCardIds.length === 0) {
                 updateStats();
                 return;
            }
            
            let maxAnimationTime = 0;
            newCardIds.forEach((id, index) => {
                const animTime = animateDrawToCarousel(id, index);
                if (animTime > maxAnimationTime) maxAnimationTime = animTime;
            });
            
            // Esperar a que todas las animaciones terminen antes de actualizar estad√≠sticas
            setTimeout(updateStats, maxAnimationTime + 100); 
        }

        // --- NUEVA FUNCI√ìN DE ANIMACI√ìN DE PLATO AL STACK ---
        function animateDishToStack(resultCard) {
            const targetStack = document.getElementById('created-dishes-stack');
            const targetRect = targetStack.getBoundingClientRect();
            const startRect = resultCard.getBoundingClientRect();

            // 1. Crear un clon para la animaci√≥n
            const clone = resultCard.cloneNode(true);
            clone.classList.remove('show'); 
            clone.style.transition = 'none';
            clone.style.position = 'fixed';
            clone.style.zIndex = 1000;
            clone.style.margin = '0';
            
            // Posici√≥n inicial (la misma que la tarjeta actual en el DOM)
            clone.style.top = `${startRect.top}px`;
            clone.style.left = `${startRect.left}px`;
            clone.style.width = `${startRect.width}px`;
            clone.style.height = `${startRect.height}px`;
            clone.style.transform = `translate(0, 0) scale(1)`; 

            document.body.appendChild(clone);
            
            // Esconder la tarjeta original inmediatamente
            resultCard.style.opacity = '0'; 

            const targetX = targetRect.left + targetRect.width / 2 - startRect.width / 2;
            const targetY = targetRect.top + targetRect.height / 2 - startRect.height / 2;
            
            // 2. Ejecutar la animaci√≥n
            setTimeout(() => {
                clone.style.transition = `transform ${ANIMATION_DURATION}ms ease-in, opacity ${ANIMATION_DURATION}ms ease-in`;
                clone.style.opacity = '0.7'; 
                // Mover al centro del stack objetivo y reducir tama√±o
                clone.style.transform = `translate(${targetX - startRect.left}px, ${targetY - startRect.top}px) rotate(0deg) scale(0.3)`;
            }, 50);

            // 3. Limpieza
            setTimeout(() => {
                clone.remove();
                resultCard.remove(); 
            }, ANIMATION_DURATION + 100); 

            return ANIMATION_DURATION
        }

        function createResultDishCard(dish) {
            const card = document.createElement('div');
            card.className = 'result-dish-card';

            const ingredientsListHtml = [
                ...dish.carbohidratos.map(name => `<li>üçö ${name}</li>`),
                ...dish.principales.map(name => `<li>ü•© ${name}</li>`),
                ...dish.verduras.map(name => `<li>ü•ó ${name}</li>`)
            ].join('');

            card.innerHTML = `
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji" style="font-size: 3em;">${dish.emoji || 'üçΩÔ∏è'}</span>
                        <div class="card-secondary-emojis">
                            <span style="color: var(--coin-color); font-weight: bold;">${dish.points} <i class="fas fa-coins"></i></span>
                        </div>
                    </div>
                    <div class="card-dish-name">${dish.name}</div>
                    <ul class="card-ingredients-list">
                        ${ingredientsListHtml}
                    </ul>
                </div>
            `;
            return card;
        }

        // --- L√ìGICA DE JUEGO PRINCIPAL ---

        function handlePlay() {
            if (isProcessingPlay || selectedCards.length === 0 || playsRemaining <= 0) return;
            isProcessingPlay = true;
            playsRemaining--;
            saveGameData('playsRemaining', playsRemaining);
            
            const selectedIngData = selectedCards.map(id => ALL_INGREDIENT_OBJECTS.get(id)).filter(ing => ing);
            
            const match = checkRecipeMatch(selectedIngData);

            // 1. Mover las tarjetas seleccionadas al centro del tablero (Animaci√≥n)
            const cardElements = selectedCards.map(id => document.querySelector(`#card-carousel .ingredient-card[data-id="${id}"]`)).filter(el => el);
            
            let maxAnimTime = 0;
            const dishBoardRect = dishBoard.getBoundingClientRect();
            
            cardElements.forEach((cardEl, index) => {
                // Calcular posici√≥n de destino en el tablero (centralizada con un peque√±o offset)
                const targetX = dishBoardRect.left + (dishBoardRect.width / 2) + ((index - 1) * 30);
                const targetY = dishBoardRect.top + (dishBoardRect.height / 2) - (cardEl.offsetHeight / 2) + 20;

                const startRect = cardEl.getBoundingClientRect();
                
                cardEl.classList.add('played');
                cardEl.style.transition = `transform ${ANIMATION_DURATION}ms ease-out, opacity ${ANIMATION_DURATION}ms ease-out`;
                cardEl.style.transform = `translate(${targetX - startRect.left}px, ${targetY - startRect.top}px) rotate(${ (index - 1) * 5 }deg) scale(1.1)`;
                cardEl.style.zIndex = 20 + index;
                
                maxAnimTime = Math.max(maxAnimTime, ANIMATION_DURATION);
            });

            // 2. Ejecutar el resultado despu√©s de la animaci√≥n de movimiento
            setTimeout(() => {
                dishBoard.innerHTML = '';
                boardPlaceholder.style.opacity = 0;
                
                if (match) {
                    handleSuccessfulDish(match, cardElements);
                } else {
                    handleFailedDish(cardElements);
                }
                
                // Limpieza post-juego
                selectedCards = [];
                updateActionButtons();
                // fillCarousel es llamado dentro de handleSuccessfulDish/handleFailedDish despu√©s de su propia animaci√≥n
            }, maxAnimTime + 100); 
        }

        function handleSuccessfulDish(dish, playedCardElements) {
            showMessage(`üéâ √âXITO: ¬°Has cocinado ${dish.name}! Ganaste ${dish.points} Monedas.`, 'success');
            
            score += 1;
            coins += dish.points;
            successfullyCreatedDishes.push(dish);
            
            const resultCard = createResultDishCard(dish);
            document.body.appendChild(resultCard); // A√±adir al body para que est√© sobre todo
            
            // Animaci√≥n: Mostrar tarjeta de plato
            setTimeout(() => {
                resultCard.classList.add('show');
            }, 50);

            // Animaci√≥n: Mover ingredientes a la pila de usados
            playedCardElements.forEach(cardEl => {
                // Agregar al pool de usados para el rebarajado
                const cardId = cardEl.getAttribute('data-id');
                usedIngredientIds.push(cardId); 
                cardEl.remove();
            });

            // Animaci√≥n: Mover tarjeta de plato a la pila de platos creados
            setTimeout(() => {
                resultCard.classList.add('hide'); // Inicia la fase de reducci√≥n
                const animTime = animateDishToStack(resultCard);

                // Esperar a que la animaci√≥n de apilamiento termine
                setTimeout(() => {
                    isProcessingPlay = false;
                    fillCarousel(); // Robar nuevas cartas
                }, animTime + 100);
            }, 1000 + ANIMATION_DURATION); 
        }

        function handleFailedDish(playedCardElements) {
            showMessage("‚ùå FALLO: No se ha encontrado ninguna receta v√°lida con esa combinaci√≥n.", 'failure');
            
            // Mover las tarjetas jugadas a la pila de usados inmediatamente
            playedCardElements.forEach(cardEl => {
                // Agregar al pool de usados para el rebarajado
                const cardId = cardEl.getAttribute('data-id');
                usedIngredientIds.push(cardId);
                cardEl.remove();
            });
            
            setTimeout(() => {
                isProcessingPlay = false;
                fillCarousel(); // Robar nuevas cartas
            }, ANIMATION_DURATION + 500); 
        }


        function handleDiscard() {
            if (isProcessingPlay || selectedCards.length === 0 || discardsRemaining <= 0) return;
            isProcessingPlay = true;
            discardsRemaining--;
            saveGameData('discardsRemaining', discardsRemaining);

            const discardedCardElements = selectedCards.map(id => document.querySelector(`#card-carousel .ingredient-card[data-id="${id}"]`)).filter(el => el);
            
            // 1. Mover las tarjetas descartadas a la pila de usados
            discardedCardElements.forEach(cardEl => {
                const cardId = cardEl.getAttribute('data-id');
                usedIngredientIds.push(cardId);
                cardEl.remove(); // Remoci√≥n inmediata del DOM
            });
            
            showMessage(`üóëÔ∏è Descartaste ${discardedCardElements.length} cartas.`, 'default');

            // 2. Limpieza y reposici√≥n
            selectedCards = [];
            updateActionButtons();

            setTimeout(() => {
                isProcessingPlay = false;
                fillCarousel(); // Robar nuevas cartas para llenar la mano
            }, 500); // Peque√±a pausa para que el usuario vea el resultado en el carrusel y el mensaje
        }


        // --- UTILIDADES ---

        function updateActionButtons() {
            const count = selectedCards.length;
            
            playButton.textContent = `Jugar Tarjetas (${count})`;
            playButton.disabled = count === 0 || playsRemaining <= 0 || isProcessingPlay;
            
            discardButton.textContent = `Descartar Tarjetas (${count})`;
            discardButton.disabled = count === 0 || discardsRemaining <= 0 || isProcessingPlay;
            
            if (count > 0) {
                boardPlaceholder.style.opacity = 0;
            } else {
                 if (dishBoard.children.length === 0) {
                    boardPlaceholder.style.opacity = 1;
                }
            }
        }

        let messageTimeout;
        function showMessage(text, type = 'default') {
            clearTimeout(messageTimeout);
            
            const displayText = document.getElementById('display-text');
            displayText.className = type;
            displayText.textContent = text;
            displayText.style.opacity = 0; 
            displayPlaceholder.style.opacity = 0;
            
            setTimeout(() => {
                displayText.style.opacity = 1;
            }, 50);

            messageTimeout = setTimeout(() => {
                displayText.style.opacity = 0;
                setTimeout(() => {
                    displayPlaceholder.style.opacity = 1;
                }, 300);
            }, 3000);
        }

        function showCollectedDishesPopup() {
            collectedDishesContainer.innerHTML = '';
            
            if (successfullyCreatedDishes.length === 0) {
                noDishesMessage.style.display = 'block';
            } else {
                noDishesMessage.style.display = 'none';
                successfullyCreatedDishes.forEach(dish => {
                    const dishCard = createResultDishCard(dish); 
                    dishCard.style.position = 'relative'; 
                    dishCard.style.transform = 'none'; 
                    dishCard.style.opacity = '1'; 
                    dishCard.style.width = '100px'; 
                    dishCard.style.height = 'auto';
                    dishCard.style.padding = '0';
                    dishCard.querySelector('.card-dish-name').style.fontSize = '0.9em';
                    dishCard.querySelector('.card-ingredients-list').style.fontSize = '0.7em';
                    dishCard.querySelector('.card-main-emoji').style.fontSize = '1.5em';
                    collectedDishesContainer.appendChild(dishCard);
                });
            }
            dishPopup.style.display = 'block';
        }

        function hideCollectedDishesPopup() {
            dishPopup.style.display = 'none';
        }
        
        function showRecipesPopup() {
            availableRecipesContainer.innerHTML = '';
            ALL_DISH_RECIPES.forEach(recipe => {
                const item = document.createElement('div');
                item.className = 'recipe-item';
                
                const carbos = recipe.carbohidratos.filter(c => c !== '-').join(', ');
                const principals = recipe.principales.filter(p => p !== '-').join(', ');
                const verduras = recipe.verduras.filter(v => v !== '-').join(', ');

                item.innerHTML = `
                    <h4>${recipe.emoji || 'üçΩÔ∏è'} ${recipe.name} (${recipe.points} Monedas)</h4>
                    <div class="recipe-ingredients">
                        ${carbos ? `**Carbohidratos:** ${carbos}<br>` : ''}
                        ${principals ? `**Principales:** ${principals}<br>` : ''}
                        ${verduras ? `**Verduras:** ${verduras}<br>` : ''}
                        ${!carbos && !principals && !verduras ? '*(Plato b√°sico o especial con requerimientos no listados)*' : ''}
                    </div>
                `;
                availableRecipesContainer.appendChild(item);
            });
            recipePopup.style.display = 'block';
        }
        
        function hideRecipesPopup() {
             recipePopup.style.display = 'none';
        }

        function handleResetGame() {
            if (!confirm("¬øEst√°s seguro de que quieres REINICIAR el juego? Se perder√° todo tu progreso (Platos creados, monedas, jugadas restantes).")) {
                return;
            }

            // Limpiar localStorage
            localStorage.removeItem('dishCreator_score');
            localStorage.removeItem('dishCreator_coins');
            localStorage.removeItem('dishCreator_playsRemaining');
            localStorage.removeItem('dishCreator_discardsRemaining');
            localStorage.removeItem('dishCreator_successfullyCreatedDishes');
            localStorage.removeItem('dishCreator_usedIngredientIds');

            // Resetear estado de la pantalla
            window.location.reload(); 
        }

        function handleShuffleCards() {
            if (isProcessingPlay || usedIngredientIds.length === 0) return;
            
            AVAILABLE_INGREDIENT_POOL.push(...usedIngredientIds);
            usedIngredientIds = [];
            AVAILABLE_INGREDIENT_POOL = AVAILABLE_INGREDIENT_POOL.sort(() => Math.random() - 0.5);
            
            showMessage(`Mazo rebarajado. Se a√±adieron ${AVAILABLE_INGREDIENT_POOL.length} cartas.`, 'default');
            
            updateStats();
            fillCarousel();
        }

        // --- INICIALIZACI√ìN ---

        document.addEventListener('DOMContentLoaded', async () => {
            
            // 1. Cargar datos necesarios
            const menuResponse = await fetch(MENU_DB_PATH);
            const menuDb = await menuResponse.json();
            setupDishRecipes(menuDb);
            
            const loadResult = await loadFilteredIngredients();
            if (!loadResult) return; 

            // 2. Inicializar estado y UI
            updateStats();
            fillCarousel(); 
            
            // 3. Configurar eventos
            playButton.addEventListener('click', handlePlay);
            discardButton.addEventListener('click', handleDiscard);
            resetGameButton.addEventListener('click', handleResetGame);
            shuffleButton.addEventListener('click', handleShuffleCards);

            // Modificaci√≥n: createdDishesStack (el mazo de platos) ahora abre el popup de platos
            createdDishesStack.addEventListener('click', showCollectedDishesPopup);
            // El bot√≥n de cerrar ya est√° dentro del popup-content, por lo que usamos querySelector
            dishPopup.querySelector('.close-button').addEventListener('click', hideCollectedDishesPopup);

            // MODIFICACI√ìN 2: El nuevo bot√≥n de acci√≥n ahora carga pantalla2
            goToPantalla2Button.addEventListener('click', () => {
                // ASUNCI√ìN: Se utiliza una funci√≥n global 'loadScreen' para el cambio de pantalla.
                // Si la funci√≥n tiene otro nombre o es local, esto deber√° ajustarse en tu entorno.
                if (typeof window.loadScreen === 'function') {
                    window.loadScreen('pantalla2');
                } else {
                    console.warn("La funci√≥n loadScreen('pantalla2') no est√° definida globalmente. No se pudo cambiar la pantalla.");
                    // Opcional: Redireccionar directamente para simular el cambio si no hay un gestor de pantallas:
                    // window.location.href = 'pantalla2.html';
                }
            });

            showRecipesButton.addEventListener('click', showRecipesPopup);
            closeRecipesButton.addEventListener('click', hideRecipesPopup);

            window.addEventListener('click', (event) => {
                if (event.target === dishPopup) { hideCollectedDishesPopup(); }
                if (event.target === recipePopup) { hideRecipesPopup(); }
            });

            showMessage("BIENVENIDO AL CREADOR DE PLATOS.", 'default');
        });
    </script>
</body>
</html>
