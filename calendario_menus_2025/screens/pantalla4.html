<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Men√∫ Semanal (Pantalla 4 - Estilo Naipe)</title>
    
    <link rel="stylesheet" href="../assets/css/card_styles.css">
    
    <style>
        /* ATENCI√ìN: Estos estilos son para la estructura de la pantalla 4. */
        body {
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 5px; 
            text-align: center;
            font-size: 0.8em;
            height: 100vh;
            margin: 0;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
        }
        
        h2 {
            font-size: 1.1em; 
            margin-bottom: 5px;
        }
        
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        #randomize-button {
            background-color: #238636;
            color: white;
            border: none;
            padding: 5px 10px; 
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        #randomize-button:hover {
            background-color: #2ea043;
        }
        
        .control-label {
            font-weight: 400;
            margin-right: 5px;
        }
        
        #consecutive-meals-select {
            padding: 4px 8px; 
            border-radius: 6px;
            border: 1px solid #30363d;
            background-color: #161b22;
            color: #c9d1d9;
            font-weight: 600;
            cursor: pointer;
        }

        /* Estilo para el nuevo toggle */
        #meals-per-day-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: #1f242c;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }
        
        /* Contenedor principal de 2 columnas para los D√çAS (4 naipes por fila) */
        #drop-zones-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2 D√çAS por fila */
            gap: 5px; /* Espacio entre los d√≠as */
            width: 99%;
            max-width: 900px;
            margin: 0px auto;
            padding: 0px;
            border: 1px solid #30363d;
            border-radius: 1px;
            background-color: #161b22;
            flex-grow: 1; 
            overflow-y: auto; 
            overflow-x: hidden;
            min-height: 0; 
        }

        /* Contenedor (drop-zone) para CADA D√çA */
        .drop-zone {
            background-color: #1f242c;
            border: 2px solid #30363d;
            border-radius: 4px;
            min-height: 70px; 
            width: 100%; /* Ocupa el 100% de su columna en el grid */
            overflow: visible;
            padding: 1px;
            transition: border-color 0.2s, background-color 0.2s;
            
            /* === Configuraci√≥n Flex para 2 tarjetas horizontales (IZQUIERDA/DERECHA) === */
            display: flex;
            flex-direction: row; /* Asegura el flujo horizontal */
            flex-wrap: wrap; 
            justify-content: space-around; /* Distribuye las 2 cartas */
            align-items: flex-start;
            position: relative;
            padding-top: 25px; /* Espacio para el label pegado */
        }
        
        /* Resalte de zona de drop */
        .drop-zone.drag-over {
            border-color: #58a6ff;
            background-color: #242931;
        }

        .zone-label {
            font-weight: 600;
            color: #58a6ff;
            font-size: 0.8em; 
            width: 100%; /* El label siempre ocupa todo el ancho */
            text-align: left;
            padding-left: 5px;
            position: absolute; /* POSICI√ìN FIJA DENTRO DEL CONTENEDOR DE D√çA */
            top: 0;
            left: 0;
            background-color: #1f242c;
            z-index: 5;
            padding-top: 1px; 
            padding-bottom: 2px;
            border-bottom: 1px solid #30363d;
        }
        
        /* Estilos espec√≠ficos para la tarjeta dentro del contenedor de 2 columnas */
        .drop-zone .card, .drop-zone .placeholder {
            /* Los estilos de 'margin' deben asegurar el espacio entre ellas */
            margin: 5px 3px 5px 3px; 
            /* Se mantiene el width definido en card_styles.css (ej. 80px) */
        }

        /* Responsive para la estructura */
        @media (max-width: 650px) {
            #drop-zones-container {
                grid-template-columns: repeat(2, 1fr);
                max-width: 400px;
            }
        }
        
        /* Placeholder con estilos de tarjeta para mantener el layout de 2 columnas */
        .placeholder {
            /* ESTILOS DE card_styles.css */
            background-color: #58a6ff;
            border: 1px dashed #58a6ff;
            opacity: 0.15;
            transition: opacity 0.3s;
            cursor: default;
        }

        .card.dragging {
            opacity: 0.1;
        }
        
    </style>
</head>
<body>

    <h2>Men√∫ semanal</h2>
    
    <div id="controls">
        <label for="consecutive-meals-select" class="control-label">Cocino para</label>
        <select id="consecutive-meals-select">
            <option value="1">1 comida seguida</option>
            <option value="2" selected>2 comidas seguidas</option>
            <option value="3">3 comidas seguidas</option>
            <option value="4">4 comidas seguidas</option>
            <option value="5">5 comidas seguidas</option>
            <option value="6">6 comidas seguidas</option>
        </select>
        
        <div id="meals-per-day-control">
            <label for="meals-per-day-toggle" class="control-label">1 o 2 Comidas/D√≠a</label>
            <input type="checkbox" id="meals-per-day-toggle" checked>
        </div>
        <button id="randomize-button">Randomizar Platos</button>
    </div>

    <div id="drop-zones-container">
        <div class="drop-zone" data-day="Lunes">
            <div class="zone-label">Lunes</div>
            <div class="card" draggable="true" data-dish="Lasa√±a">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">üçù</span>
                        <div class="card-secondary-emojis">üßÖüçÖ</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Lasa√±a de Carne</p>
                        <ul class="card-ingredients-list">
                            <li>Carne Molida</li>
                            <li>Pasta Lasa√±a</li>
                            <li>Tomate</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="card" draggable="true" data-dish="Sopa">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">üç≤</span>
                        <div class="card-secondary-emojis">ü•ïü•î</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Sopa de Verduras</p>
                        <ul class="card-ingredients-list">
                            <li>Pollo</li>
                            <li>Papa</li>
                            <li>Zanahoria</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="drop-zone" data-day="Martes">
            <div class="zone-label">Martes</div>
            <div class="card" draggable="true" data-dish="Fideos">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">üçú</span>
                        <div class="card-secondary-emojis">üßÄüå∂Ô∏è</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Fideos con Queso</p>
                        <ul class="card-ingredients-list">
                            <li>Leche</li>
                            <li>Fideos</li>
                            <li>Queso</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="card" draggable="true" data-dish="Cazuela">
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">ü•£</span>
                        <div class="card-secondary-emojis">üåΩüéÉ</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">Cazuela de Pollo</p>
                        <ul class="card-ingredients-list">
                            <li>Pollo</li>
                            <li>Zapallo</li>
                            <li>Choclo</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="drop-zone" data-day="Mi√©rcoles">
            <div class="zone-label">Mi√©rcoles</div>
        </div>
        <div class="drop-zone" data-day="Jueves">
            <div class="zone-label">Jueves</div>
        </div>
        <div class="drop-zone" data-day="Viernes">
            <div class="zone-label">Viernes</div>
        </div>
        <div class="drop-zone" data-day="S√°bado">
            <div class="zone-label">S√°bado</div>
        </div>
        <div class="drop-zone" data-day="Domingo">
            <div class="zone-label">Domingo</div>
        </div>
    </div>

    <div id="loading-message" style="color: #58a6ff; margin-top: 5px;">Cargando men√∫ desde GitHub...</div>

    <script>
        // ===============================================
        // CONFIGURACI√ìN DE DATOS
        // ===============================================
        const DATA_URL = 'https://djless.github.io/magordito_menu_semanal/calendario_menus_2025/data/menu_db.json';
        const INVENTORY_DATA_URL = 'https://djless.github.io/magordito_menu_semanal/calendario_menus_2025/data/inventario_db.json'; 
        
        // CAMBIO: CARDS_PER_ZONE y TOTAL_CARDS ahora son variables y se inicializan din√°micamente
        let CARDS_PER_ZONE = 2; // Valor por defecto
        const DAYS_COUNT = 7;
        let TOTAL_CARDS = CARDS_PER_ZONE * DAYS_COUNT;
        
        let allDishes = []; 
        let menuData = null; 
        let allowedDishes = [];
        const SELECTION_STORAGE_KEY = 'selectedDishesAndIngredients'; 
        const CUSTOM_ING_STORAGE_KEY = 'customIngredientsConfig'; 
        let customIngredients = {}; 
        let selectedComponentsSet = new Set(); 
        let INGREDIENT_EMOJI_MAP = {}; 

        const container = document.getElementById('drop-zones-container');
        const randomizeButton = document.getElementById('randomize-button');
        const allZones = Array.from(document.querySelectorAll('.drop-zone'));
        const loadingMessage = document.getElementById('loading-message');
        const consecutiveMealsSelect = document.getElementById('consecutive-meals-select');
        // Nuevo elemento de control
        const mealsPerDayToggle = document.getElementById('meals-per-day-toggle'); 


        // ===============================================
        // DRAG & DROP VARIABLES GLOBALES
        // ===============================================
        let draggedCard = null;
        let placeholder = null; 
        let lastRectMap = new Map(); 
        
        // --- Variables de Throttling (Optimizaci√≥n de Fluidez) ---
        let isUpdating = false; 
        let lastDragEventData = { zone: null, clientX: 0 }; 
        // ---------------------------------------------------------


        // ===============================================
        // FUNCIONES DE UTILIDAD D&D
        // ===============================================

        function getAllCards() {
            // Obtiene todas las tarjetas (visibles y arrastradas) en el orden actual del DOM, excluyendo el placeholder y labels.
            return Array.from(document.querySelectorAll('.drop-zone .card'));
        }

        function registerLiveTransforms() {
            // Guarda la posici√≥n (FIRST) de todas las tarjetas ANTES del cambio de posici√≥n en el DOM.
            getAllCards().forEach(card => {
                const rect = card.getBoundingClientRect();
                lastRectMap.set(card, { top: rect.top, left: rect.left, width: rect.width, height: rect.height });
            });
        }

        function applyFLIPAnimation(initialCards) {
             // 1. INVERT (Mover visualmente al estado 'FIRST' capturado en dragover)
            initialCards.forEach(card => {
                // Solo animamos si la tarjeta no es la que estamos arrastrando
                if (card === draggedCard) return; 

                const lastRect = lastRectMap.get(card); // FIRST
                if (!lastRect) return;

                const newRect = card.getBoundingClientRect(); // LAST

                const deltaX = lastRect.left - newRect.left;
                const deltaY = lastRect.top - newRect.top;

                if (deltaX !== 0 || deltaY !== 0) {
                    card.style.transition = 'none';
                    card.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                } else {
                    card.style.transform = '';
                }
            });

            void document.body.offsetHeight; // Forzar reflow

            // 2. PLAY (Animar a la posici√≥n final)
            initialCards.forEach(card => {
                if (card === draggedCard) return; 

                // Resetear transform para animar al nuevo lugar
                card.style.transition = ''; 
                card.style.transform = '';¬†
            });
        }

        function clearLiveTransforms() {
            if (draggedCard) {
                // Asegura la visibilidad y limpia la clase dragging
                draggedCard.classList.remove('dragging');
                draggedCard.style.display = ''; 
                draggedCard.style.transform = ''; 
            }
            if (placeholder) {
                // Si el placeholder todav√≠a existe (porque fall√≥ el drop), lo eliminamos.
                placeholder.remove();
            }
            lastRectMap.clear();
            draggedCard = null;
            placeholder = null;
            allZones.forEach(zone => zone.classList.remove('drag-over'));
        }

        function getDragAfterElement(container, x) {
            // Determina la tarjeta o placeholder despu√©s de la cual se debe insertar el placeholder.
            // Excluye la tarjeta arrastrada (invisible), el placeholder (si ya est√°) y el label.
            const elements = Array.from(container.children).filter(
                element => element !== draggedCard && element !== placeholder && element.classList && (element.classList.contains('card') || element.classList.contains('placeholder'))
            );
            
            if (elements.length === 0) return null; 

            return elements.reduce((closest, child) => {
                const rect = child.getBoundingClientRect();
                const center = rect.left + rect.width / 2;
                const offset = x - center;

                // Solo si el puntero est√° ANTES del centro del elemento.
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }


        /**
         * Reordena el DOM de todas las 7 zonas para lograr el efecto cascada en vivo.
         * Esta funci√≥n se llama a trav√©s de requestAnimationFrame.
         * @param {HTMLElement} currentZone La zona donde se detect√≥ el movimiento.
         * @param {number} clientX La posici√≥n X del rat√≥n.
         */
        function liveReorderAndFlip(currentZone, clientX) {
            if (!draggedCard || !placeholder) return;

            // 1. FIRST: Capture positions before any DOM changes.
            registerLiveTransforms();
            const initialCards = getAllCards();

            // 2. Local Reorder: Insert placeholder in the CURRENT zone.
            if (placeholder.parentNode) placeholder.remove(); 
            
            // a) Determinar d√≥nde se insertar√≠a el placeholder dentro de la ZONA actual.
            const afterElement = getDragAfterElement(currentZone, clientX);
            
            if (afterElement == null) {
                // Insertar al final de la zona (despu√©s de todos los elementos)
                currentZone.appendChild(placeholder);
            } else {
                // Insertar justo antes del elemento detectado.
                currentZone.insertBefore(placeholder, afterElement);
            }

            // 3. Global Reorder (The movement between zones)

            // A. Obtener la secuencia global *actual* del DOM (Placeholder ya est√° en su lugar).
            // Excluimos la tarjeta arrastrada (oculta) y los labels.
            let currentGlobalSequence = allZones.flatMap(zone => 
                Array.from(zone.children).filter(el => el !== zone.querySelector('.zone-label') && el !== draggedCard)
            );
            
            // B. Reconstrucci√≥n: Limpiar y re-agregar.
            allZones.forEach(z => {
                const label = z.querySelector('.zone-label');
                // Almacenamos el label
                if(label) label.remove();
                
                // Limpiar todos los hijos
                z.innerHTML = '';
                
                // Re-insertamos el label (asegurando que sea el primer hijo)
                if(label) z.appendChild(label); 
            });

            // C. Apendizar elementos a sus nuevas zonas seg√∫n CARDS_PER_ZONE
            currentGlobalSequence.forEach((el, index) => {
                const targetZoneIndex = Math.floor(index / CARDS_PER_ZONE);
                const targetZone = allZones[targetZoneIndex];
                if (targetZone) {
                    targetZone.appendChild(el);
                }
            });

            // 4. INVERT & PLAY: Animar
            applyFLIPAnimation(initialCards);
        }
        
        // --- Funci√≥n de Throttling ---
        function processDragOverUpdate() {
            if (draggedCard && placeholder && lastDragEventData.zone) {
                // Llama a la funci√≥n pesada con los √∫ltimos datos registrados
                liveReorderAndFlip(lastDragEventData.zone, lastDragEventData.clientX); 
            }
            isUpdating = false; // Resetear la bandera para permitir el siguiente frame
        }
        // ------------------------------

        // ===============================================
        // L√ìGICA DE DATOS Y RENDERIZADO
        // ===============================================
        
        function getRandomElement(arr) {
            if (!arr || arr.length === 0 || (arr.length === 1 && arr[0] === "-")) return 'N/A';
            const randomIndex = Math.floor(Math.random() * arr.length);
            return arr[randomIndex];
        }

        function getDishEmoji(dishName, selectedPrincipal) {
            if (INGREDIENT_EMOJI_MAP[dishName]) {
                return INGREDIENT_EMOJI_MAP[dishName];
            }
            if (INGREDIENT_EMOJI_MAP[selectedPrincipal] && selectedPrincipal !== 'N/A') {
                const genericEmojis = ["ü•©", "üçó", "üêü", "üç§", "ü´ò"];
                if (!genericEmojis.includes(INGREDIENT_EMOJI_MAP[selectedPrincipal])) {
                    return INGREDIENT_EMOJI_MAP[selectedPrincipal];
                }
            }
            const principalObject = menuData?.platos_principales.find(p => p.nombre === dishName);
            if (principalObject?.principales?.[0] && INGREDIENT_EMOJI_MAP[principalObject.principales[0]]) {
                return INGREDIENT_EMOJI_MAP[principalObject.principales[0]];
            }
            return "üçΩÔ∏è";
        }

        function getDishDetails(dishName) {
            if (!menuData || !menuData.platos_principales) {
                return { principal: 'N/A', carbohidrato: 'N/A', verdura: 'N/A', emojiPrincipal: 'üçΩÔ∏è' };
            }

            const dishObject = menuData.platos_principales.find(p => p.nombre === dishName);
            if (!dishObject) {
                return { principal: 'N/A', carbohidrato: 'N/A', verdura: 'N/A', emojiPrincipal: 'üçΩÔ∏è' };
            }

            let principales = (dishObject.principales || []).filter(i => i && i !== '-');
            let carbohidratos = (dishObject.carbohidratos || []).filter(i => i && i !== '-');
            let verduras = (dishObject.verduras || []).filter(i => i && i !== '-');

            if (selectedComponentsSet.size > 0) {
                principales = principales.filter(ing => selectedComponentsSet.has(ing));
                carbohidratos = carbohidratos.filter(ing => selectedComponentsSet.has(ing));
                verduras = verduras.filter(ing => selectedComponentsSet.has(ing));
            }

            if (Object.keys(customIngredients).length > 0) {
                principales = principales.filter(ing => customIngredients[ing] !== false);
                carbohidratos = carbohidratos.filter(ing => customIngredients[ing] !== false);
                verduras = verduras.filter(ing => customIngredients[ing] !== false);
            }

            const selectedPrincipal = getRandomElement(principales);
            const selectedCarbohidrato = getRandomElement(carbohidratos);
            const selectedVerdura = getRandomElement(verduras);

            return {
                principal: selectedPrincipal,
                carbohidrato: selectedCarbohidrato,
                verdura: selectedVerdura,
                emojiPrincipal: getDishEmoji(dishName, selectedPrincipal)
            };
        }

        function getRandomDishes(count) {
            const consecutiveCount = parseInt(consecutiveMealsSelect.value, 10);
            const selectedDishes = [];
            const dishesToSelectFrom = [...allowedDishes];

            for (let i = 0; i < count; i++) {
                if (dishesToSelectFrom.length === 0) break;

                let randomDishIndex = Math.floor(Math.random() * dishesToSelectFrom.length);
                let selectedDish = dishesToSelectFrom[randomDishIndex];
                
                selectedDishes.push(selectedDish);
                
                // L√≥gica de comidas consecutivas (se aplica solo al inicio de un bloque de d√≠a)
                if ((i % CARDS_PER_ZONE) === 0 && (i + 1) < count) {
                    for (let j = 1; j < consecutiveCount && (i + j) < count; j++) {
                        selectedDishes.push(selectedDish);
                    }
                    // Saltar los slots llenados por la comida consecutiva
                    i += consecutiveCount - 1; 
                }

                const originalLength = dishesToSelectFrom.length;
                dishesToSelectFrom.splice(randomDishIndex, 1);
                
                if (dishesToSelectFrom.length === originalLength) break;
            }
            return selectedDishes;
        }

        function createCard(dishName) {
            const details = getDishDetails(dishName);
            
            let secondaryEmojis = '';
            if (details.carbohidrato && details.carbohidrato !== 'N/A' && INGREDIENT_EMOJI_MAP[details.carbohidrato]) {
                secondaryEmojis += INGREDIENT_EMOJI_MAP[details.carbohidrato];
            }
            if (details.verdura && details.verdura !== 'N/A' && INGREDIENT_EMOJI_MAP[details.verdura]) {
                secondaryEmojis += INGREDIENT_EMOJI_MAP[details.verdura];
            }

            const card = document.createElement('div');
            card.className = 'card';
            card.draggable = true;
            card.setAttribute('data-dish', dishName);

            const ingredientsListHtml = [details.principal, details.carbohidrato, details.verdura]
                .filter(i => i && i !== 'N/A')
                .map(i => `<li>${i}</li>`)
                .join('');

            card.innerHTML = `
                <div class="card-inner-content">
                    <div class="card-image-zone">
                        <span class="card-main-emoji">${details.emojiPrincipal}</span>
                        <div class="card-secondary-emojis">${secondaryEmojis}</div>
                    </div>
                    <div class="card-ingredients-zone">
                        <p class="card-dish-name">${dishName}</p>
                        <ul class="card-ingredients-list">
                            ${ingredientsListHtml}
                        </ul>
                    </div>
                </div>
            `;
            return card;
        }

        function renderCards() {
            loadingMessage.textContent = 'Randomizando men√∫...';
            
            // Recalcular el total de tarjetas basado en el toggle
            updateCardsPerZone(); 
            
            allZones.forEach(zone => zone.innerHTML = `<div class="zone-label">${zone.getAttribute('data-day')}</div>`);

            const randomDishes = getRandomDishes(TOTAL_CARDS);
            
            allZones.forEach((zone, zoneIndex) => {
                const label = zone.querySelector('.zone-label');
                zone.innerHTML = '';
                zone.appendChild(label); 

                const start = zoneIndex * CARDS_PER_ZONE;
                const end = start + CARDS_PER_ZONE;
                
                randomDishes.slice(start, end).forEach(dishName => {
                    if (dishName) {
                        zone.appendChild(createCard(dishName));
                    }
                });
            });

            loadingMessage.textContent = 'Men√∫ listo.';
            if (randomDishes.length < TOTAL_CARDS) {
                 loadingMessage.textContent += ` (ADVERTENCIA: Solo se pudieron generar ${randomDishes.length} platos √∫nicos disponibles.)`;
            }
        }
        
        /**
         * Actualiza la variable global CARDS_PER_ZONE y TOTAL_CARDS
         */
        function updateCardsPerZone() {
            CARDS_PER_ZONE = mealsPerDayToggle.checked ? 2 : 1;
            TOTAL_CARDS = CARDS_PER_ZONE * DAYS_COUNT;
        }

        async function loadMenuData() {
            try {
                const menuResponse = await fetch(DATA_URL);
                if (!menuResponse.ok) throw new Error(`Error al cargar el men√∫: ${menuResponse.status}`);
                menuData = await menuResponse.json();
                allDishes = menuData.platos_principales.map(d => d.nombre);
                
                const inventoryResponse = await fetch(INVENTORY_DATA_URL);
                if (!inventoryResponse.ok) throw new Error(`Error al cargar el inventario: ${inventoryResponse.status}`);
                const inventoryData = await inventoryResponse.json();
                
                INGREDIENT_EMOJI_MAP = {};
                inventoryData.inventario.forEach(item => {
                    INGREDIENT_EMOJI_MAP[item.nombre] = item.emoji; 
                });

                loadSelectionFilters();
                
                // Inicializar las variables con el estado del toggle y renderizar
                renderCards(); 

            } catch (error) {
                console.error("Error al cargar los datos:", error);
                loadingMessage.textContent = `Error al cargar los datos: ${error.message}`;
                loadingMessage.style.color = 'red';
            }
        }
        
        function loadSelectionFilters() {
            const selectionString = localStorage.getItem(SELECTION_STORAGE_KEY);
            if (selectionString) {
                const selections = JSON.parse(selectionString);
                selectedComponentsSet = new Set([
                    ...(Array.isArray(selections.dishes) ? selections.dishes : []), 
                    ...(Array.isArray(selections.ingredients) ? selections.ingredients : [])
                ]);
            } else {
                selectedComponentsSet = new Set();
            }

            const customIngString = localStorage.getItem(CUSTOM_ING_STORAGE_KEY);
            if (customIngString) {
                customIngredients = JSON.parse(customIngString);
            } else {
                customIngredients = {};
            }

            if (selectedComponentsSet.size > 0) {
                allowedDishes = allDishes.filter(dishName => selectedComponentsSet.has(dishName));
            } else {
                allowedDishes = allDishes;
            }

            allowedDishes = allowedDishes.filter(dishName => {
                const dish = menuData.platos_principales.find(d => d.nombre === dishName);
                if (!dish) return true;

                const allIngredients = [...(dish.principales || []), ...(dish.carbohidratos || []), ...(dish.verduras || [])]
                    .filter(i => i && i !== '-');

                const hasOmittedIngredient = allIngredients.some(ing => customIngredients[ing] === false);

                return !hasOmittedIngredient; 
            });
            
            if (allowedDishes.length === 0) {
                loadingMessage.textContent = 'ADVERTENCIA: No hay platos disponibles con los filtros y omisiones seleccionadas.';
                loadingMessage.style.color = 'orange';
            }
        }

        // ===============================================
        // DRAG & DROP EVENT LISTENERS
        // ===============================================

        document.querySelectorAll('.drop-zone').forEach(zone => {
            zone.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('card')) {
                    draggedCard = e.target;
                    draggedCard.classList.add('dragging');
                    lastDragEventData.zone = draggedCard.parentNode; // Almacenar la zona de inicio

                    // Crear el placeholder
                    placeholder = draggedCard.cloneNode(true);
                    placeholder.classList.add('placeholder');
                    placeholder.classList.remove('card', 'dragging');
                    placeholder.style.visibility = 'visible';
                    placeholder.draggable = false;
                    placeholder.style.width = draggedCard.style.width; 
                    placeholder.style.paddingBottom = draggedCard.style.paddingBottom;

                    e.dataTransfer.effectAllowed = 'move';
                    const emptyImg = new Image();
                    emptyImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                    e.dataTransfer.setDragImage(emptyImg, 0, 0);

                    // Insertar placeholder y ocultar tarjeta real
                    setTimeout(() => {
                        draggedCard.style.display = 'none';
                        // Insertamos el placeholder en la posici√≥n original para que el liveReorderAndFlip lo recoja
                        if (draggedCard.parentNode) {
                            draggedCard.parentNode.insertBefore(placeholder, draggedCard);
                        }
                    }, 0);
                }
            });

            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('drag-over');

                // 1. Actualizar los √∫ltimos datos del evento
                lastDragEventData.zone = zone;
                lastDragEventData.clientX = e.clientX;

                // 2. Si no estamos ya actualizando, programar la actualizaci√≥n en el pr√≥ximo frame
                if (draggedCard && placeholder && !isUpdating) {
                    isUpdating = true;
                    // Llama a la funci√≥n pesada en el pr√≥ximo cuadro de animaci√≥n
                    requestAnimationFrame(processDragOverUpdate); 
                }
            });

            zone.addEventListener('dragleave', (e) => {
                if (!zone.contains(e.relatedTarget)) {
                    zone.classList.remove('drag-over');
                }
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');

                if (draggedCard && placeholder && placeholder.parentNode) {
                    
                    // PASO CRUCIAL: Reemplazamos el placeholder por la tarjeta arrastrada (permanente).
                    placeholder.parentNode.replaceChild(draggedCard, placeholder);
                    
                    // Anulamos la referencia del placeholder para indicar a `dragend` que la operaci√≥n fue exitosa.
                    placeholder = null;
                }
            });
        });

        document.addEventListener('dragend', (e) => {
            // Reiniciar la bandera de throttling para limpiar cualquier actualizaci√≥n pendiente
            isUpdating = false; 

            if (draggedCard) {
                // Si `placeholder` NO es null, el drop fall√≥ o se solt√≥ fuera.
                if (placeholder && placeholder.parentNode) {
                    // Revertimos la √∫ltima acci√≥n: reemplazamos el placeholder por la tarjeta real.
                    placeholder.parentNode.replaceChild(draggedCard, placeholder);
                }
                
                // Limpieza final de clases, visibilidad y variables globales.
                clearLiveTransforms(); 
            }
        });

        document.addEventListener('dragover', (e) => {
            // Permite el drop en todo el documento para que los eventos de zona se disparen correctamente
            e.preventDefault(); 
        });

        // ===============================================
        // INICIALIZACI√ìN
        // ===============================================

        randomizeButton.addEventListener('click', renderCards);
        consecutiveMealsSelect.addEventListener('change', renderCards); 
        // EVENTO PARA EL NUEVO TOGGLE
        mealsPerDayToggle.addEventListener('change', renderCards); 
        
        loadMenuData();
    </script>
</body>
</html>